import "nanopb.proto";

import "types.proto";

// a value for 'passing around'.
// A value can either be identified by a name, or a reference
// which is an opaque handle unique to the originating party.

// the following use cases make sense:

// just a typed value: {type, any one of actual values}

// a 'descriptor for further reference':
// {type,name,ref}

// a name/value pair:
// {type,name, any one of actual values}

// a 'referencing update' - it is known the receiver has
// seen a 'descriptor for further reference' and therefore
// can interpret the following:
// {type, ref, any one of actual values}

// a 'full update' - complete descriptor with current value
// {type, name, ref, any one of actual values, otpionaly 'changed'}
// 'changed' might be useful if only full updates are used, and
// the receiver would prefer to know about changed values

// if a Value message is used in enclosing object like 'Pin',
// the name in the enclosing object should be used and not the
// optional name in Value.

message Value {

    required ScalarType   type = 10;
    optional string       name = 20  [(nanopb).max_size = 41];
    optional uint32        ref = 25;
    optional bool      changed = 30;  // relative to last use


    // actual values

    // One of the following must be filled in,
    // depending on type.
    optional bool    halbit   = 100;
    optional double  halfloat = 101;
    optional sint32  hals32   = 102;
    optional uint32  halu32   = 103;

    optional bytes   v_bytes  = 120;
    optional int32   v_int32  = 130;
    optional int64   v_int63  = 140;
    optional uint32  v_uint32 = 150;
    optional uint64  v_uint63 = 160;
    optional double  v_double = 170;
    optional string  v_string = 180   [(nanopb).max_size = 41];
    optional bool    v_bool   = 190;
}
