// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object.proto

#ifndef PROTOBUF_object_2eproto__INCLUDED
#define PROTOBUF_object_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
#include "types.pb.h"
#include "value.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_object_2eproto();
void protobuf_AssignDesc_object_2eproto();
void protobuf_ShutdownFile_object_2eproto();

class Instance;
class Originator;
class Pin;
class Signal;
class Param;
class Function;
class Thread;
class Component;
class Ring;
class Member;
class Group;
class Object;

// ===================================================================

class Instance : public ::google::protobuf::Message {
 public:
  Instance();
  virtual ~Instance();

  Instance(const Instance& from);

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance& default_instance();

  void Swap(Instance* other);

  // implements Message ----------------------------------------------

  Instance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 30;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 30;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional sint32 id = 40;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 40;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Instance)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Instance* default_instance_;
};
// -------------------------------------------------------------------

class Originator : public ::google::protobuf::Message {
 public:
  Originator();
  virtual ~Originator();

  Originator(const Originator& from);

  inline Originator& operator=(const Originator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Originator& default_instance();

  void Swap(Originator* other);

  // implements Message ----------------------------------------------

  Originator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Originator& from);
  void MergeFrom(const Originator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OriginType origin = 10;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 10;
  inline ::OriginType origin() const;
  inline void set_origin(::OriginType value);

  // optional .OriginDetail detail = 20;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 20;
  inline ::OriginDetail detail() const;
  inline void set_detail(::OriginDetail value);

  // optional string name = 30;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 30;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional sint32 id = 40;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 40;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .Instance instance = 50;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 50;
  inline const ::Instance& instance() const;
  inline ::Instance* mutable_instance();
  inline ::Instance* release_instance();
  inline void set_allocated_instance(::Instance* instance);

  // @@protoc_insertion_point(class_scope:Originator)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_detail();
  inline void clear_has_detail();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_instance();
  inline void clear_has_instance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int origin_;
  int detail_;
  ::std::string* name_;
  ::Instance* instance_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Originator* default_instance_;
};
// -------------------------------------------------------------------

class Pin : public ::google::protobuf::Message {
 public:
  Pin();
  virtual ~Pin();

  Pin(const Pin& from);

  inline Pin& operator=(const Pin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pin& default_instance();

  void Swap(Pin* other);

  // implements Message ----------------------------------------------

  Pin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pin& from);
  void MergeFrom(const Pin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ScalarType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::ScalarType type() const;
  inline void set_type(::ScalarType value);

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional bool halbit = 100;
  inline bool has_halbit() const;
  inline void clear_halbit();
  static const int kHalbitFieldNumber = 100;
  inline bool halbit() const;
  inline void set_halbit(bool value);

  // optional double halfloat = 101;
  inline bool has_halfloat() const;
  inline void clear_halfloat();
  static const int kHalfloatFieldNumber = 101;
  inline double halfloat() const;
  inline void set_halfloat(double value);

  // optional sint32 hals32 = 102;
  inline bool has_hals32() const;
  inline void clear_hals32();
  static const int kHals32FieldNumber = 102;
  inline ::google::protobuf::int32 hals32() const;
  inline void set_hals32(::google::protobuf::int32 value);

  // optional uint32 halu32 = 103;
  inline bool has_halu32() const;
  inline void clear_halu32();
  static const int kHalu32FieldNumber = 103;
  inline ::google::protobuf::uint32 halu32() const;
  inline void set_halu32(::google::protobuf::uint32 value);

  // optional sint32 owner = 40;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 40;
  inline ::google::protobuf::int32 owner() const;
  inline void set_owner(::google::protobuf::int32 value);

  // optional bool linked = 50;
  inline bool has_linked() const;
  inline void clear_linked();
  static const int kLinkedFieldNumber = 50;
  inline bool linked() const;
  inline void set_linked(bool value);

  // optional string oldname = 60;
  inline bool has_oldname() const;
  inline void clear_oldname();
  static const int kOldnameFieldNumber = 60;
  inline const ::std::string& oldname() const;
  inline void set_oldname(const ::std::string& value);
  inline void set_oldname(const char* value);
  inline void set_oldname(const char* value, size_t size);
  inline ::std::string* mutable_oldname();
  inline ::std::string* release_oldname();
  inline void set_allocated_oldname(::std::string* oldname);

  // optional double epsilon = 80;
  inline bool has_epsilon() const;
  inline void clear_epsilon();
  static const int kEpsilonFieldNumber = 80;
  inline double epsilon() const;
  inline void set_epsilon(double value);

  // optional uint32 flags = 90;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 90;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Pin)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_halbit();
  inline void clear_has_halbit();
  inline void set_has_halfloat();
  inline void clear_has_halfloat();
  inline void set_has_hals32();
  inline void clear_has_hals32();
  inline void set_has_halu32();
  inline void clear_has_halu32();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_linked();
  inline void clear_has_linked();
  inline void set_has_oldname();
  inline void clear_has_oldname();
  inline void set_has_epsilon();
  inline void clear_has_epsilon();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int type_;
  ::google::protobuf::uint32 handle_;
  double halfloat_;
  ::google::protobuf::int32 hals32_;
  bool halbit_;
  bool linked_;
  ::google::protobuf::uint32 halu32_;
  ::google::protobuf::int32 owner_;
  ::std::string* oldname_;
  double epsilon_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Pin* default_instance_;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  void Swap(Signal* other);

  // implements Message ----------------------------------------------

  Signal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ScalarType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::ScalarType type() const;
  inline void set_type(::ScalarType value);

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional bool halbit = 100;
  inline bool has_halbit() const;
  inline void clear_halbit();
  static const int kHalbitFieldNumber = 100;
  inline bool halbit() const;
  inline void set_halbit(bool value);

  // optional double halfloat = 101;
  inline bool has_halfloat() const;
  inline void clear_halfloat();
  static const int kHalfloatFieldNumber = 101;
  inline double halfloat() const;
  inline void set_halfloat(double value);

  // optional sint32 hals32 = 102;
  inline bool has_hals32() const;
  inline void clear_hals32();
  static const int kHals32FieldNumber = 102;
  inline ::google::protobuf::int32 hals32() const;
  inline void set_hals32(::google::protobuf::int32 value);

  // optional uint32 halu32 = 103;
  inline bool has_halu32() const;
  inline void clear_halu32();
  static const int kHalu32FieldNumber = 103;
  inline ::google::protobuf::uint32 halu32() const;
  inline void set_halu32(::google::protobuf::uint32 value);

  // optional uint32 readers = 50;
  inline bool has_readers() const;
  inline void clear_readers();
  static const int kReadersFieldNumber = 50;
  inline ::google::protobuf::uint32 readers() const;
  inline void set_readers(::google::protobuf::uint32 value);

  // optional uint32 writers = 60;
  inline bool has_writers() const;
  inline void clear_writers();
  static const int kWritersFieldNumber = 60;
  inline ::google::protobuf::uint32 writers() const;
  inline void set_writers(::google::protobuf::uint32 value);

  // optional uint32 bidirs = 70;
  inline bool has_bidirs() const;
  inline void clear_bidirs();
  static const int kBidirsFieldNumber = 70;
  inline ::google::protobuf::uint32 bidirs() const;
  inline void set_bidirs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Signal)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_halbit();
  inline void clear_has_halbit();
  inline void set_has_halfloat();
  inline void clear_has_halfloat();
  inline void set_has_hals32();
  inline void clear_has_hals32();
  inline void set_has_halu32();
  inline void clear_has_halu32();
  inline void set_has_readers();
  inline void clear_has_readers();
  inline void set_has_writers();
  inline void clear_has_writers();
  inline void set_has_bidirs();
  inline void clear_has_bidirs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int type_;
  ::google::protobuf::uint32 handle_;
  double halfloat_;
  bool halbit_;
  ::google::protobuf::int32 hals32_;
  ::google::protobuf::uint32 halu32_;
  ::google::protobuf::uint32 readers_;
  ::google::protobuf::uint32 writers_;
  ::google::protobuf::uint32 bidirs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Signal* default_instance_;
};
// -------------------------------------------------------------------

class Param : public ::google::protobuf::Message {
 public:
  Param();
  virtual ~Param();

  Param(const Param& from);

  inline Param& operator=(const Param& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Param& default_instance();

  void Swap(Param* other);

  // implements Message ----------------------------------------------

  Param* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Param& from);
  void MergeFrom(const Param& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ScalarType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::ScalarType type() const;
  inline void set_type(::ScalarType value);

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional bool halbit = 100;
  inline bool has_halbit() const;
  inline void clear_halbit();
  static const int kHalbitFieldNumber = 100;
  inline bool halbit() const;
  inline void set_halbit(bool value);

  // optional double halfloat = 101;
  inline bool has_halfloat() const;
  inline void clear_halfloat();
  static const int kHalfloatFieldNumber = 101;
  inline double halfloat() const;
  inline void set_halfloat(double value);

  // optional sint32 hals32 = 102;
  inline bool has_hals32() const;
  inline void clear_hals32();
  static const int kHals32FieldNumber = 102;
  inline ::google::protobuf::int32 hals32() const;
  inline void set_hals32(::google::protobuf::int32 value);

  // optional uint32 halu32 = 103;
  inline bool has_halu32() const;
  inline void clear_halu32();
  static const int kHalu32FieldNumber = 103;
  inline ::google::protobuf::uint32 halu32() const;
  inline void set_halu32(::google::protobuf::uint32 value);

  // optional .HalParamDirection pdir = 50;
  inline bool has_pdir() const;
  inline void clear_pdir();
  static const int kPdirFieldNumber = 50;
  inline ::HalParamDirection pdir() const;
  inline void set_pdir(::HalParamDirection value);

  // optional string oldname = 60;
  inline bool has_oldname() const;
  inline void clear_oldname();
  static const int kOldnameFieldNumber = 60;
  inline const ::std::string& oldname() const;
  inline void set_oldname(const ::std::string& value);
  inline void set_oldname(const char* value);
  inline void set_oldname(const char* value, size_t size);
  inline ::std::string* mutable_oldname();
  inline ::std::string* release_oldname();
  inline void set_allocated_oldname(::std::string* oldname);

  // optional sint32 owner = 70;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 70;
  inline ::google::protobuf::int32 owner() const;
  inline void set_owner(::google::protobuf::int32 value);

  // optional sint32 runtime = 80;
  inline bool has_runtime() const;
  inline void clear_runtime();
  static const int kRuntimeFieldNumber = 80;
  inline ::google::protobuf::int32 runtime() const;
  inline void set_runtime(::google::protobuf::int32 value);

  // optional sint32 maytime = 90;
  inline bool has_maytime() const;
  inline void clear_maytime();
  static const int kMaytimeFieldNumber = 90;
  inline ::google::protobuf::int32 maytime() const;
  inline void set_maytime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Param)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_halbit();
  inline void clear_has_halbit();
  inline void set_has_halfloat();
  inline void clear_has_halfloat();
  inline void set_has_hals32();
  inline void clear_has_hals32();
  inline void set_has_halu32();
  inline void clear_has_halu32();
  inline void set_has_pdir();
  inline void clear_has_pdir();
  inline void set_has_oldname();
  inline void clear_has_oldname();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_runtime();
  inline void clear_has_runtime();
  inline void set_has_maytime();
  inline void clear_has_maytime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int type_;
  ::google::protobuf::uint32 handle_;
  double halfloat_;
  bool halbit_;
  ::google::protobuf::int32 hals32_;
  ::google::protobuf::uint32 halu32_;
  int pdir_;
  ::std::string* oldname_;
  ::google::protobuf::int32 owner_;
  ::google::protobuf::int32 runtime_;
  ::google::protobuf::int32 maytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Param* default_instance_;
};
// -------------------------------------------------------------------

class Function : public ::google::protobuf::Message {
 public:
  Function();
  virtual ~Function();

  Function(const Function& from);

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Function& default_instance();

  void Swap(Function* other);

  // implements Message ----------------------------------------------

  Function* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Function)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 handle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Function* default_instance_;
};
// -------------------------------------------------------------------

class Thread : public ::google::protobuf::Message {
 public:
  Thread();
  virtual ~Thread();

  Thread(const Thread& from);

  inline Thread& operator=(const Thread& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Thread& default_instance();

  void Swap(Thread* other);

  // implements Message ----------------------------------------------

  Thread* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Thread& from);
  void MergeFrom(const Thread& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional bool uses_fp = 30;
  inline bool has_uses_fp() const;
  inline void clear_uses_fp();
  static const int kUsesFpFieldNumber = 30;
  inline bool uses_fp() const;
  inline void set_uses_fp(bool value);

  // optional uint32 period = 40;
  inline bool has_period() const;
  inline void clear_period();
  static const int kPeriodFieldNumber = 40;
  inline ::google::protobuf::uint32 period() const;
  inline void set_period(::google::protobuf::uint32 value);

  // optional sint32 prioritiy = 50;
  inline bool has_prioritiy() const;
  inline void clear_prioritiy();
  static const int kPrioritiyFieldNumber = 50;
  inline ::google::protobuf::int32 prioritiy() const;
  inline void set_prioritiy(::google::protobuf::int32 value);

  // optional uint32 task_id = 60;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 60;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // optional uint32 cpu_id = 70;
  inline bool has_cpu_id() const;
  inline void clear_cpu_id();
  static const int kCpuIdFieldNumber = 70;
  inline ::google::protobuf::uint32 cpu_id() const;
  inline void set_cpu_id(::google::protobuf::uint32 value);

  // repeated .Function functions = 80;
  inline int functions_size() const;
  inline void clear_functions();
  static const int kFunctionsFieldNumber = 80;
  inline const ::Function& functions(int index) const;
  inline ::Function* mutable_functions(int index);
  inline ::Function* add_functions();
  inline const ::google::protobuf::RepeatedPtrField< ::Function >&
      functions() const;
  inline ::google::protobuf::RepeatedPtrField< ::Function >*
      mutable_functions();

  // @@protoc_insertion_point(class_scope:Thread)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_uses_fp();
  inline void clear_has_uses_fp();
  inline void set_has_period();
  inline void clear_has_period();
  inline void set_has_prioritiy();
  inline void clear_has_prioritiy();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_cpu_id();
  inline void clear_has_cpu_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 handle_;
  bool uses_fp_;
  ::google::protobuf::uint32 period_;
  ::google::protobuf::int32 prioritiy_;
  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 cpu_id_;
  ::google::protobuf::RepeatedPtrField< ::Function > functions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Thread* default_instance_;
};
// -------------------------------------------------------------------

class Component : public ::google::protobuf::Message {
 public:
  Component();
  virtual ~Component();

  Component(const Component& from);

  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Component& default_instance();

  void Swap(Component* other);

  // implements Message ----------------------------------------------

  Component* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Component& from);
  void MergeFrom(const Component& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional sint32 comp_id = 30;
  inline bool has_comp_id() const;
  inline void clear_comp_id();
  static const int kCompIdFieldNumber = 30;
  inline ::google::protobuf::int32 comp_id() const;
  inline void set_comp_id(::google::protobuf::int32 value);

  // optional uint32 type = 40;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 40;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 state = 50;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 50;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 last_update = 60;
  inline bool has_last_update() const;
  inline void clear_last_update();
  static const int kLastUpdateFieldNumber = 60;
  inline ::google::protobuf::uint32 last_update() const;
  inline void set_last_update(::google::protobuf::uint32 value);

  // optional uint32 last_bound = 70;
  inline bool has_last_bound() const;
  inline void clear_last_bound();
  static const int kLastBoundFieldNumber = 70;
  inline ::google::protobuf::uint32 last_bound() const;
  inline void set_last_bound(::google::protobuf::uint32 value);

  // optional uint32 last_unbound = 80;
  inline bool has_last_unbound() const;
  inline void clear_last_unbound();
  static const int kLastUnboundFieldNumber = 80;
  inline ::google::protobuf::uint32 last_unbound() const;
  inline void set_last_unbound(::google::protobuf::uint32 value);

  // optional uint32 pid = 90;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 90;
  inline ::google::protobuf::uint32 pid() const;
  inline void set_pid(::google::protobuf::uint32 value);

  // repeated string args = 100;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 100;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // @@protoc_insertion_point(class_scope:Component)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_comp_id();
  inline void clear_has_comp_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_last_update();
  inline void clear_has_last_update();
  inline void set_has_last_bound();
  inline void clear_has_last_bound();
  inline void set_has_last_unbound();
  inline void clear_has_last_unbound();
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 comp_id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 last_update_;
  ::google::protobuf::uint32 last_bound_;
  ::google::protobuf::uint32 last_unbound_;
  ::google::protobuf::uint32 pid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Component* default_instance_;
};
// -------------------------------------------------------------------

class Ring : public ::google::protobuf::Message {
 public:
  Ring();
  virtual ~Ring();

  Ring(const Ring& from);

  inline Ring& operator=(const Ring& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ring& default_instance();

  void Swap(Ring* other);

  // implements Message ----------------------------------------------

  Ring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ring& from);
  void MergeFrom(const Ring& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional sint32 owner = 40;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 40;
  inline ::google::protobuf::int32 owner() const;
  inline void set_owner(::google::protobuf::int32 value);

  // optional bool stream = 50;
  inline bool has_stream() const;
  inline void clear_stream();
  static const int kStreamFieldNumber = 50;
  inline bool stream() const;
  inline void set_stream(bool value);

  // optional bool wmutex = 60;
  inline bool has_wmutex() const;
  inline void clear_wmutex();
  static const int kWmutexFieldNumber = 60;
  inline bool wmutex() const;
  inline void set_wmutex(bool value);

  // optional bool rmutex = 70;
  inline bool has_rmutex() const;
  inline void clear_rmutex();
  static const int kRmutexFieldNumber = 70;
  inline bool rmutex() const;
  inline void set_rmutex(bool value);

  // optional bool rtapi_shm = 80;
  inline bool has_rtapi_shm() const;
  inline void clear_rtapi_shm();
  static const int kRtapiShmFieldNumber = 80;
  inline bool rtapi_shm() const;
  inline void set_rtapi_shm(bool value);

  // optional sint32 reader = 90;
  inline bool has_reader() const;
  inline void clear_reader();
  static const int kReaderFieldNumber = 90;
  inline ::google::protobuf::int32 reader() const;
  inline void set_reader(::google::protobuf::int32 value);

  // optional sint32 writer = 100;
  inline bool has_writer() const;
  inline void clear_writer();
  static const int kWriterFieldNumber = 100;
  inline ::google::protobuf::int32 writer() const;
  inline void set_writer(::google::protobuf::int32 value);

  // optional sint32 size = 110;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 110;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional sint32 scratchpad = 120;
  inline bool has_scratchpad() const;
  inline void clear_scratchpad();
  static const int kScratchpadFieldNumber = 120;
  inline ::google::protobuf::int32 scratchpad() const;
  inline void set_scratchpad(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ring)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_stream();
  inline void clear_has_stream();
  inline void set_has_wmutex();
  inline void clear_has_wmutex();
  inline void set_has_rmutex();
  inline void clear_has_rmutex();
  inline void set_has_rtapi_shm();
  inline void clear_has_rtapi_shm();
  inline void set_has_reader();
  inline void clear_has_reader();
  inline void set_has_writer();
  inline void clear_has_writer();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_scratchpad();
  inline void clear_has_scratchpad();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 owner_;
  bool stream_;
  bool wmutex_;
  bool rmutex_;
  bool rtapi_shm_;
  ::google::protobuf::int32 reader_;
  ::google::protobuf::int32 writer_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 scratchpad_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Ring* default_instance_;
};
// -------------------------------------------------------------------

class Member : public ::google::protobuf::Message {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Member& default_instance();

  void Swap(Member* other);

  // implements Message ----------------------------------------------

  Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ObjectType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::ObjectType type() const;
  inline void set_type(::ObjectType value);

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional sint32 userarg1 = 30;
  inline bool has_userarg1() const;
  inline void clear_userarg1();
  static const int kUserarg1FieldNumber = 30;
  inline ::google::protobuf::int32 userarg1() const;
  inline void set_userarg1(::google::protobuf::int32 value);

  // optional double epsilon = 40;
  inline bool has_epsilon() const;
  inline void clear_epsilon();
  static const int kEpsilonFieldNumber = 40;
  inline double epsilon() const;
  inline void set_epsilon(double value);

  // optional bool halbit = 100;
  inline bool has_halbit() const;
  inline void clear_halbit();
  static const int kHalbitFieldNumber = 100;
  inline bool halbit() const;
  inline void set_halbit(bool value);

  // optional double halfloat = 101;
  inline bool has_halfloat() const;
  inline void clear_halfloat();
  static const int kHalfloatFieldNumber = 101;
  inline double halfloat() const;
  inline void set_halfloat(double value);

  // optional sint32 hals32 = 102;
  inline bool has_hals32() const;
  inline void clear_hals32();
  static const int kHals32FieldNumber = 102;
  inline ::google::protobuf::int32 hals32() const;
  inline void set_hals32(::google::protobuf::int32 value);

  // optional uint32 halu32 = 103;
  inline bool has_halu32() const;
  inline void clear_halu32();
  static const int kHalu32FieldNumber = 103;
  inline ::google::protobuf::uint32 halu32() const;
  inline void set_halu32(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Member)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_userarg1();
  inline void clear_has_userarg1();
  inline void set_has_epsilon();
  inline void clear_has_epsilon();
  inline void set_has_halbit();
  inline void clear_has_halbit();
  inline void set_has_halfloat();
  inline void clear_has_halfloat();
  inline void set_has_hals32();
  inline void clear_has_hals32();
  inline void set_has_halu32();
  inline void clear_has_halu32();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int type_;
  ::google::protobuf::uint32 handle_;
  double epsilon_;
  ::google::protobuf::int32 userarg1_;
  bool halbit_;
  double halfloat_;
  ::google::protobuf::int32 hals32_;
  ::google::protobuf::uint32 halu32_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Member* default_instance_;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  void Swap(Group* other);

  // implements Message ----------------------------------------------

  Group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 20;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 20;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 handle = 25;
  inline bool has_handle() const;
  inline void clear_handle();
  static const int kHandleFieldNumber = 25;
  inline ::google::protobuf::uint32 handle() const;
  inline void set_handle(::google::protobuf::uint32 value);

  // optional sint32 id = 30;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 30;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional sint32 userarg1 = 50;
  inline bool has_userarg1() const;
  inline void clear_userarg1();
  static const int kUserarg1FieldNumber = 50;
  inline ::google::protobuf::int32 userarg1() const;
  inline void set_userarg1(::google::protobuf::int32 value);

  // optional sint32 userarg2 = 60;
  inline bool has_userarg2() const;
  inline void clear_userarg2();
  static const int kUserarg2FieldNumber = 60;
  inline ::google::protobuf::int32 userarg2() const;
  inline void set_userarg2(::google::protobuf::int32 value);

  // optional sint32 serial = 70;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 70;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);

  // repeated .Member member = 80;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 80;
  inline const ::Member& member(int index) const;
  inline ::Member* mutable_member(int index);
  inline ::Member* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::Member >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::Member >*
      mutable_member();

  // @@protoc_insertion_point(class_scope:Group)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_handle();
  inline void clear_has_handle();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_userarg1();
  inline void clear_has_userarg1();
  inline void set_has_userarg2();
  inline void clear_has_userarg2();
  inline void set_has_serial();
  inline void clear_has_serial();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 userarg1_;
  ::google::protobuf::int32 userarg2_;
  ::google::protobuf::RepeatedPtrField< ::Member > member_;
  ::google::protobuf::int32 serial_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Group* default_instance_;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  Object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ObjectType type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::ObjectType type() const;
  inline void set_type(::ObjectType value);

  // optional .Value value = 20;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 20;
  inline const ::Value& value() const;
  inline ::Value* mutable_value();
  inline ::Value* release_value();
  inline void set_allocated_value(::Value* value);

  // optional .Originator origin = 30;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 30;
  inline const ::Originator& origin() const;
  inline ::Originator* mutable_origin();
  inline ::Originator* release_origin();
  inline void set_allocated_origin(::Originator* origin);

  // optional .Instance instance = 40;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 40;
  inline const ::Instance& instance() const;
  inline ::Instance* mutable_instance();
  inline ::Instance* release_instance();
  inline void set_allocated_instance(::Instance* instance);

  // optional .Pin pin = 100;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 100;
  inline const ::Pin& pin() const;
  inline ::Pin* mutable_pin();
  inline ::Pin* release_pin();
  inline void set_allocated_pin(::Pin* pin);

  // optional .Signal signal = 110;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 110;
  inline const ::Signal& signal() const;
  inline ::Signal* mutable_signal();
  inline ::Signal* release_signal();
  inline void set_allocated_signal(::Signal* signal);

  // optional .Param param = 120;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 120;
  inline const ::Param& param() const;
  inline ::Param* mutable_param();
  inline ::Param* release_param();
  inline void set_allocated_param(::Param* param);

  // optional .Thread thread = 130;
  inline bool has_thread() const;
  inline void clear_thread();
  static const int kThreadFieldNumber = 130;
  inline const ::Thread& thread() const;
  inline ::Thread* mutable_thread();
  inline ::Thread* release_thread();
  inline void set_allocated_thread(::Thread* thread);

  // optional .Component comp = 140;
  inline bool has_comp() const;
  inline void clear_comp();
  static const int kCompFieldNumber = 140;
  inline const ::Component& comp() const;
  inline ::Component* mutable_comp();
  inline ::Component* release_comp();
  inline void set_allocated_comp(::Component* comp);

  // optional .Ring ring = 150;
  inline bool has_ring() const;
  inline void clear_ring();
  static const int kRingFieldNumber = 150;
  inline const ::Ring& ring() const;
  inline ::Ring* mutable_ring();
  inline ::Ring* release_ring();
  inline void set_allocated_ring(::Ring* ring);

  // optional .Group group = 160;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 160;
  inline const ::Group& group() const;
  inline ::Group* mutable_group();
  inline ::Group* release_group();
  inline void set_allocated_group(::Group* group);

  // optional .Member member = 170;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 170;
  inline const ::Member& member() const;
  inline ::Member* mutable_member();
  inline ::Member* release_member();
  inline void set_allocated_member(::Member* member);

  // optional .Function function = 180;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 180;
  inline const ::Function& function() const;
  inline ::Function* mutable_function();
  inline ::Function* release_function();
  inline void set_allocated_function(::Function* function);

  // @@protoc_insertion_point(class_scope:Object)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_thread();
  inline void clear_has_thread();
  inline void set_has_comp();
  inline void clear_has_comp();
  inline void set_has_ring();
  inline void clear_has_ring();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_function();
  inline void clear_has_function();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Value* value_;
  ::Originator* origin_;
  ::Instance* instance_;
  ::Pin* pin_;
  ::Signal* signal_;
  ::Param* param_;
  ::Thread* thread_;
  ::Component* comp_;
  ::Ring* ring_;
  ::Group* group_;
  ::Member* member_;
  ::Function* function_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_object_2eproto();
  friend void protobuf_AssignDesc_object_2eproto();
  friend void protobuf_ShutdownFile_object_2eproto();

  void InitAsDefaultInstance();
  static Object* default_instance_;
};
// ===================================================================


// ===================================================================

// Instance

// optional string name = 30;
inline bool Instance::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Instance::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Instance::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Instance::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Instance::name() const {
  return *name_;
}
inline void Instance::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Instance::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Instance::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instance::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Instance::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instance::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 id = 40;
inline bool Instance::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Instance::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Instance::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Instance::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Instance::id() const {
  return id_;
}
inline void Instance::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// Originator

// optional .OriginType origin = 10;
inline bool Originator::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Originator::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Originator::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Originator::clear_origin() {
  origin_ = 10;
  clear_has_origin();
}
inline ::OriginType Originator::origin() const {
  return static_cast< ::OriginType >(origin_);
}
inline void Originator::set_origin(::OriginType value) {
  assert(::OriginType_IsValid(value));
  set_has_origin();
  origin_ = value;
}

// optional .OriginDetail detail = 20;
inline bool Originator::has_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Originator::set_has_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Originator::clear_has_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Originator::clear_detail() {
  detail_ = 10;
  clear_has_detail();
}
inline ::OriginDetail Originator::detail() const {
  return static_cast< ::OriginDetail >(detail_);
}
inline void Originator::set_detail(::OriginDetail value) {
  assert(::OriginDetail_IsValid(value));
  set_has_detail();
  detail_ = value;
}

// optional string name = 30;
inline bool Originator::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Originator::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Originator::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Originator::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Originator::name() const {
  return *name_;
}
inline void Originator::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Originator::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Originator::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Originator::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Originator::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Originator::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 id = 40;
inline bool Originator::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Originator::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Originator::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Originator::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Originator::id() const {
  return id_;
}
inline void Originator::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .Instance instance = 50;
inline bool Originator::has_instance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Originator::set_has_instance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Originator::clear_has_instance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Originator::clear_instance() {
  if (instance_ != NULL) instance_->::Instance::Clear();
  clear_has_instance();
}
inline const ::Instance& Originator::instance() const {
  return instance_ != NULL ? *instance_ : *default_instance_->instance_;
}
inline ::Instance* Originator::mutable_instance() {
  set_has_instance();
  if (instance_ == NULL) instance_ = new ::Instance;
  return instance_;
}
inline ::Instance* Originator::release_instance() {
  clear_has_instance();
  ::Instance* temp = instance_;
  instance_ = NULL;
  return temp;
}
inline void Originator::set_allocated_instance(::Instance* instance) {
  delete instance_;
  instance_ = instance;
  if (instance) {
    set_has_instance();
  } else {
    clear_has_instance();
  }
}

// -------------------------------------------------------------------

// Pin

// optional .ScalarType type = 10;
inline bool Pin::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pin::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pin::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pin::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ScalarType Pin::type() const {
  return static_cast< ::ScalarType >(type_);
}
inline void Pin::set_type(::ScalarType value) {
  assert(::ScalarType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 20;
inline bool Pin::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pin::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pin::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pin::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Pin::name() const {
  return *name_;
}
inline void Pin::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Pin::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Pin::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pin::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Pin::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Pin::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Pin::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pin::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pin::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pin::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Pin::handle() const {
  return handle_;
}
inline void Pin::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional bool halbit = 100;
inline bool Pin::has_halbit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pin::set_has_halbit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pin::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pin::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Pin::halbit() const {
  return halbit_;
}
inline void Pin::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
}

// optional double halfloat = 101;
inline bool Pin::has_halfloat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pin::set_has_halfloat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pin::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pin::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Pin::halfloat() const {
  return halfloat_;
}
inline void Pin::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
}

// optional sint32 hals32 = 102;
inline bool Pin::has_hals32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Pin::set_has_hals32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Pin::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Pin::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Pin::hals32() const {
  return hals32_;
}
inline void Pin::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
}

// optional uint32 halu32 = 103;
inline bool Pin::has_halu32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Pin::set_has_halu32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Pin::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Pin::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Pin::halu32() const {
  return halu32_;
}
inline void Pin::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
}

// optional sint32 owner = 40;
inline bool Pin::has_owner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Pin::set_has_owner() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Pin::clear_has_owner() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Pin::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Pin::owner() const {
  return owner_;
}
inline void Pin::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
}

// optional bool linked = 50;
inline bool Pin::has_linked() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Pin::set_has_linked() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Pin::clear_has_linked() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Pin::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool Pin::linked() const {
  return linked_;
}
inline void Pin::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
}

// optional string oldname = 60;
inline bool Pin::has_oldname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Pin::set_has_oldname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Pin::clear_has_oldname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Pin::clear_oldname() {
  if (oldname_ != &::google::protobuf::internal::kEmptyString) {
    oldname_->clear();
  }
  clear_has_oldname();
}
inline const ::std::string& Pin::oldname() const {
  return *oldname_;
}
inline void Pin::set_oldname(const ::std::string& value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
}
inline void Pin::set_oldname(const char* value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
}
inline void Pin::set_oldname(const char* value, size_t size) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pin::mutable_oldname() {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  return oldname_;
}
inline ::std::string* Pin::release_oldname() {
  clear_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldname_;
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Pin::set_allocated_oldname(::std::string* oldname) {
  if (oldname_ != &::google::protobuf::internal::kEmptyString) {
    delete oldname_;
  }
  if (oldname) {
    set_has_oldname();
    oldname_ = oldname;
  } else {
    clear_has_oldname();
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double epsilon = 80;
inline bool Pin::has_epsilon() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Pin::set_has_epsilon() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Pin::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Pin::clear_epsilon() {
  epsilon_ = 0;
  clear_has_epsilon();
}
inline double Pin::epsilon() const {
  return epsilon_;
}
inline void Pin::set_epsilon(double value) {
  set_has_epsilon();
  epsilon_ = value;
}

// optional uint32 flags = 90;
inline bool Pin::has_flags() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Pin::set_has_flags() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Pin::clear_has_flags() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Pin::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 Pin::flags() const {
  return flags_;
}
inline void Pin::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// Signal

// optional .ScalarType type = 10;
inline bool Signal::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ScalarType Signal::type() const {
  return static_cast< ::ScalarType >(type_);
}
inline void Signal::set_type(::ScalarType value) {
  assert(::ScalarType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 20;
inline bool Signal::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signal::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signal::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Signal::name() const {
  return *name_;
}
inline void Signal::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Signal::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Signal::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Signal::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Signal::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Signal::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Signal::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Signal::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Signal::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Signal::handle() const {
  return handle_;
}
inline void Signal::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional bool halbit = 100;
inline bool Signal::has_halbit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Signal::set_has_halbit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Signal::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Signal::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Signal::halbit() const {
  return halbit_;
}
inline void Signal::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
}

// optional double halfloat = 101;
inline bool Signal::has_halfloat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Signal::set_has_halfloat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Signal::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Signal::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Signal::halfloat() const {
  return halfloat_;
}
inline void Signal::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
}

// optional sint32 hals32 = 102;
inline bool Signal::has_hals32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Signal::set_has_hals32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Signal::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Signal::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Signal::hals32() const {
  return hals32_;
}
inline void Signal::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
}

// optional uint32 halu32 = 103;
inline bool Signal::has_halu32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Signal::set_has_halu32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Signal::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Signal::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Signal::halu32() const {
  return halu32_;
}
inline void Signal::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
}

// optional uint32 readers = 50;
inline bool Signal::has_readers() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Signal::set_has_readers() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Signal::clear_has_readers() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Signal::clear_readers() {
  readers_ = 0u;
  clear_has_readers();
}
inline ::google::protobuf::uint32 Signal::readers() const {
  return readers_;
}
inline void Signal::set_readers(::google::protobuf::uint32 value) {
  set_has_readers();
  readers_ = value;
}

// optional uint32 writers = 60;
inline bool Signal::has_writers() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Signal::set_has_writers() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Signal::clear_has_writers() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Signal::clear_writers() {
  writers_ = 0u;
  clear_has_writers();
}
inline ::google::protobuf::uint32 Signal::writers() const {
  return writers_;
}
inline void Signal::set_writers(::google::protobuf::uint32 value) {
  set_has_writers();
  writers_ = value;
}

// optional uint32 bidirs = 70;
inline bool Signal::has_bidirs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Signal::set_has_bidirs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Signal::clear_has_bidirs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Signal::clear_bidirs() {
  bidirs_ = 0u;
  clear_has_bidirs();
}
inline ::google::protobuf::uint32 Signal::bidirs() const {
  return bidirs_;
}
inline void Signal::set_bidirs(::google::protobuf::uint32 value) {
  set_has_bidirs();
  bidirs_ = value;
}

// -------------------------------------------------------------------

// Param

// optional .ScalarType type = 10;
inline bool Param::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Param::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Param::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Param::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ScalarType Param::type() const {
  return static_cast< ::ScalarType >(type_);
}
inline void Param::set_type(::ScalarType value) {
  assert(::ScalarType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 20;
inline bool Param::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Param::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Param::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Param::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Param::name() const {
  return *name_;
}
inline void Param::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Param::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Param::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Param::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Param::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Param::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Param::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Param::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Param::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Param::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Param::handle() const {
  return handle_;
}
inline void Param::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional bool halbit = 100;
inline bool Param::has_halbit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Param::set_has_halbit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Param::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Param::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Param::halbit() const {
  return halbit_;
}
inline void Param::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
}

// optional double halfloat = 101;
inline bool Param::has_halfloat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Param::set_has_halfloat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Param::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Param::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Param::halfloat() const {
  return halfloat_;
}
inline void Param::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
}

// optional sint32 hals32 = 102;
inline bool Param::has_hals32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Param::set_has_hals32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Param::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Param::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Param::hals32() const {
  return hals32_;
}
inline void Param::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
}

// optional uint32 halu32 = 103;
inline bool Param::has_halu32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Param::set_has_halu32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Param::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Param::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Param::halu32() const {
  return halu32_;
}
inline void Param::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
}

// optional .HalParamDirection pdir = 50;
inline bool Param::has_pdir() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Param::set_has_pdir() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Param::clear_has_pdir() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Param::clear_pdir() {
  pdir_ = 64;
  clear_has_pdir();
}
inline ::HalParamDirection Param::pdir() const {
  return static_cast< ::HalParamDirection >(pdir_);
}
inline void Param::set_pdir(::HalParamDirection value) {
  assert(::HalParamDirection_IsValid(value));
  set_has_pdir();
  pdir_ = value;
}

// optional string oldname = 60;
inline bool Param::has_oldname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Param::set_has_oldname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Param::clear_has_oldname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Param::clear_oldname() {
  if (oldname_ != &::google::protobuf::internal::kEmptyString) {
    oldname_->clear();
  }
  clear_has_oldname();
}
inline const ::std::string& Param::oldname() const {
  return *oldname_;
}
inline void Param::set_oldname(const ::std::string& value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
}
inline void Param::set_oldname(const char* value) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(value);
}
inline void Param::set_oldname(const char* value, size_t size) {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  oldname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Param::mutable_oldname() {
  set_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    oldname_ = new ::std::string;
  }
  return oldname_;
}
inline ::std::string* Param::release_oldname() {
  clear_has_oldname();
  if (oldname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldname_;
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Param::set_allocated_oldname(::std::string* oldname) {
  if (oldname_ != &::google::protobuf::internal::kEmptyString) {
    delete oldname_;
  }
  if (oldname) {
    set_has_oldname();
    oldname_ = oldname;
  } else {
    clear_has_oldname();
    oldname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 owner = 70;
inline bool Param::has_owner() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Param::set_has_owner() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Param::clear_has_owner() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Param::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Param::owner() const {
  return owner_;
}
inline void Param::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
}

// optional sint32 runtime = 80;
inline bool Param::has_runtime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Param::set_has_runtime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Param::clear_has_runtime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Param::clear_runtime() {
  runtime_ = 0;
  clear_has_runtime();
}
inline ::google::protobuf::int32 Param::runtime() const {
  return runtime_;
}
inline void Param::set_runtime(::google::protobuf::int32 value) {
  set_has_runtime();
  runtime_ = value;
}

// optional sint32 maytime = 90;
inline bool Param::has_maytime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Param::set_has_maytime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Param::clear_has_maytime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Param::clear_maytime() {
  maytime_ = 0;
  clear_has_maytime();
}
inline ::google::protobuf::int32 Param::maytime() const {
  return maytime_;
}
inline void Param::set_maytime(::google::protobuf::int32 value) {
  set_has_maytime();
  maytime_ = value;
}

// -------------------------------------------------------------------

// Function

// optional string name = 20;
inline bool Function::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Function::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Function::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Function::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Function::name() const {
  return *name_;
}
inline void Function::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Function::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Function::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Function::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Function::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Function::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Function::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Function::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Function::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Function::handle() const {
  return handle_;
}
inline void Function::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// -------------------------------------------------------------------

// Thread

// optional string name = 20;
inline bool Thread::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Thread::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Thread::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Thread::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Thread::name() const {
  return *name_;
}
inline void Thread::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Thread::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Thread::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Thread::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Thread::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Thread::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Thread::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Thread::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Thread::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Thread::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Thread::handle() const {
  return handle_;
}
inline void Thread::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional bool uses_fp = 30;
inline bool Thread::has_uses_fp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Thread::set_has_uses_fp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Thread::clear_has_uses_fp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Thread::clear_uses_fp() {
  uses_fp_ = false;
  clear_has_uses_fp();
}
inline bool Thread::uses_fp() const {
  return uses_fp_;
}
inline void Thread::set_uses_fp(bool value) {
  set_has_uses_fp();
  uses_fp_ = value;
}

// optional uint32 period = 40;
inline bool Thread::has_period() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Thread::set_has_period() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Thread::clear_has_period() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Thread::clear_period() {
  period_ = 0u;
  clear_has_period();
}
inline ::google::protobuf::uint32 Thread::period() const {
  return period_;
}
inline void Thread::set_period(::google::protobuf::uint32 value) {
  set_has_period();
  period_ = value;
}

// optional sint32 prioritiy = 50;
inline bool Thread::has_prioritiy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Thread::set_has_prioritiy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Thread::clear_has_prioritiy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Thread::clear_prioritiy() {
  prioritiy_ = 0;
  clear_has_prioritiy();
}
inline ::google::protobuf::int32 Thread::prioritiy() const {
  return prioritiy_;
}
inline void Thread::set_prioritiy(::google::protobuf::int32 value) {
  set_has_prioritiy();
  prioritiy_ = value;
}

// optional uint32 task_id = 60;
inline bool Thread::has_task_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Thread::set_has_task_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Thread::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Thread::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 Thread::task_id() const {
  return task_id_;
}
inline void Thread::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
}

// optional uint32 cpu_id = 70;
inline bool Thread::has_cpu_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Thread::set_has_cpu_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Thread::clear_has_cpu_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Thread::clear_cpu_id() {
  cpu_id_ = 0u;
  clear_has_cpu_id();
}
inline ::google::protobuf::uint32 Thread::cpu_id() const {
  return cpu_id_;
}
inline void Thread::set_cpu_id(::google::protobuf::uint32 value) {
  set_has_cpu_id();
  cpu_id_ = value;
}

// repeated .Function functions = 80;
inline int Thread::functions_size() const {
  return functions_.size();
}
inline void Thread::clear_functions() {
  functions_.Clear();
}
inline const ::Function& Thread::functions(int index) const {
  return functions_.Get(index);
}
inline ::Function* Thread::mutable_functions(int index) {
  return functions_.Mutable(index);
}
inline ::Function* Thread::add_functions() {
  return functions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Function >&
Thread::functions() const {
  return functions_;
}
inline ::google::protobuf::RepeatedPtrField< ::Function >*
Thread::mutable_functions() {
  return &functions_;
}

// -------------------------------------------------------------------

// Component

// optional string name = 20;
inline bool Component::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Component::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Component::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Component::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Component::name() const {
  return *name_;
}
inline void Component::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Component::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Component::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Component::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Component::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Component::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Component::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Component::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Component::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Component::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Component::handle() const {
  return handle_;
}
inline void Component::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional sint32 comp_id = 30;
inline bool Component::has_comp_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Component::set_has_comp_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Component::clear_has_comp_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Component::clear_comp_id() {
  comp_id_ = 0;
  clear_has_comp_id();
}
inline ::google::protobuf::int32 Component::comp_id() const {
  return comp_id_;
}
inline void Component::set_comp_id(::google::protobuf::int32 value) {
  set_has_comp_id();
  comp_id_ = value;
}

// optional uint32 type = 40;
inline bool Component::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Component::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Component::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Component::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Component::type() const {
  return type_;
}
inline void Component::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 state = 50;
inline bool Component::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Component::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Component::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Component::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 Component::state() const {
  return state_;
}
inline void Component::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 last_update = 60;
inline bool Component::has_last_update() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Component::set_has_last_update() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Component::clear_has_last_update() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Component::clear_last_update() {
  last_update_ = 0u;
  clear_has_last_update();
}
inline ::google::protobuf::uint32 Component::last_update() const {
  return last_update_;
}
inline void Component::set_last_update(::google::protobuf::uint32 value) {
  set_has_last_update();
  last_update_ = value;
}

// optional uint32 last_bound = 70;
inline bool Component::has_last_bound() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Component::set_has_last_bound() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Component::clear_has_last_bound() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Component::clear_last_bound() {
  last_bound_ = 0u;
  clear_has_last_bound();
}
inline ::google::protobuf::uint32 Component::last_bound() const {
  return last_bound_;
}
inline void Component::set_last_bound(::google::protobuf::uint32 value) {
  set_has_last_bound();
  last_bound_ = value;
}

// optional uint32 last_unbound = 80;
inline bool Component::has_last_unbound() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Component::set_has_last_unbound() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Component::clear_has_last_unbound() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Component::clear_last_unbound() {
  last_unbound_ = 0u;
  clear_has_last_unbound();
}
inline ::google::protobuf::uint32 Component::last_unbound() const {
  return last_unbound_;
}
inline void Component::set_last_unbound(::google::protobuf::uint32 value) {
  set_has_last_unbound();
  last_unbound_ = value;
}

// optional uint32 pid = 90;
inline bool Component::has_pid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Component::set_has_pid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Component::clear_has_pid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Component::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 Component::pid() const {
  return pid_;
}
inline void Component::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
}

// repeated string args = 100;
inline int Component::args_size() const {
  return args_.size();
}
inline void Component::clear_args() {
  args_.Clear();
}
inline const ::std::string& Component::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* Component::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void Component::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void Component::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void Component::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Component::add_args() {
  return args_.Add();
}
inline void Component::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void Component::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void Component::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Component::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Component::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// Ring

// optional string name = 20;
inline bool Ring::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ring::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ring::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ring::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Ring::name() const {
  return *name_;
}
inline void Ring::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Ring::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Ring::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ring::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Ring::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ring::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Ring::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ring::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ring::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ring::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Ring::handle() const {
  return handle_;
}
inline void Ring::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional sint32 owner = 40;
inline bool Ring::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ring::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ring::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ring::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Ring::owner() const {
  return owner_;
}
inline void Ring::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
}

// optional bool stream = 50;
inline bool Ring::has_stream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ring::set_has_stream() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ring::clear_has_stream() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ring::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool Ring::stream() const {
  return stream_;
}
inline void Ring::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
}

// optional bool wmutex = 60;
inline bool Ring::has_wmutex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ring::set_has_wmutex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ring::clear_has_wmutex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ring::clear_wmutex() {
  wmutex_ = false;
  clear_has_wmutex();
}
inline bool Ring::wmutex() const {
  return wmutex_;
}
inline void Ring::set_wmutex(bool value) {
  set_has_wmutex();
  wmutex_ = value;
}

// optional bool rmutex = 70;
inline bool Ring::has_rmutex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ring::set_has_rmutex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ring::clear_has_rmutex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ring::clear_rmutex() {
  rmutex_ = false;
  clear_has_rmutex();
}
inline bool Ring::rmutex() const {
  return rmutex_;
}
inline void Ring::set_rmutex(bool value) {
  set_has_rmutex();
  rmutex_ = value;
}

// optional bool rtapi_shm = 80;
inline bool Ring::has_rtapi_shm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ring::set_has_rtapi_shm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ring::clear_has_rtapi_shm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ring::clear_rtapi_shm() {
  rtapi_shm_ = false;
  clear_has_rtapi_shm();
}
inline bool Ring::rtapi_shm() const {
  return rtapi_shm_;
}
inline void Ring::set_rtapi_shm(bool value) {
  set_has_rtapi_shm();
  rtapi_shm_ = value;
}

// optional sint32 reader = 90;
inline bool Ring::has_reader() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ring::set_has_reader() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ring::clear_has_reader() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ring::clear_reader() {
  reader_ = 0;
  clear_has_reader();
}
inline ::google::protobuf::int32 Ring::reader() const {
  return reader_;
}
inline void Ring::set_reader(::google::protobuf::int32 value) {
  set_has_reader();
  reader_ = value;
}

// optional sint32 writer = 100;
inline bool Ring::has_writer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ring::set_has_writer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ring::clear_has_writer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ring::clear_writer() {
  writer_ = 0;
  clear_has_writer();
}
inline ::google::protobuf::int32 Ring::writer() const {
  return writer_;
}
inline void Ring::set_writer(::google::protobuf::int32 value) {
  set_has_writer();
  writer_ = value;
}

// optional sint32 size = 110;
inline bool Ring::has_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ring::set_has_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ring::clear_has_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ring::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 Ring::size() const {
  return size_;
}
inline void Ring::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional sint32 scratchpad = 120;
inline bool Ring::has_scratchpad() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ring::set_has_scratchpad() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ring::clear_has_scratchpad() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ring::clear_scratchpad() {
  scratchpad_ = 0;
  clear_has_scratchpad();
}
inline ::google::protobuf::int32 Ring::scratchpad() const {
  return scratchpad_;
}
inline void Ring::set_scratchpad(::google::protobuf::int32 value) {
  set_has_scratchpad();
  scratchpad_ = value;
}

// -------------------------------------------------------------------

// Member

// optional .ObjectType type = 10;
inline bool Member::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Member::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Member::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Member::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ObjectType Member::type() const {
  return static_cast< ::ObjectType >(type_);
}
inline void Member::set_type(::ObjectType value) {
  assert(::ObjectType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 20;
inline bool Member::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Member::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Member::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Member::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Member::name() const {
  return *name_;
}
inline void Member::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Member::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Member::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Member::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Member::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Member::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Member::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Member::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Member::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Member::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Member::handle() const {
  return handle_;
}
inline void Member::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional sint32 userarg1 = 30;
inline bool Member::has_userarg1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Member::set_has_userarg1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Member::clear_has_userarg1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Member::clear_userarg1() {
  userarg1_ = 0;
  clear_has_userarg1();
}
inline ::google::protobuf::int32 Member::userarg1() const {
  return userarg1_;
}
inline void Member::set_userarg1(::google::protobuf::int32 value) {
  set_has_userarg1();
  userarg1_ = value;
}

// optional double epsilon = 40;
inline bool Member::has_epsilon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Member::set_has_epsilon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Member::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Member::clear_epsilon() {
  epsilon_ = 0;
  clear_has_epsilon();
}
inline double Member::epsilon() const {
  return epsilon_;
}
inline void Member::set_epsilon(double value) {
  set_has_epsilon();
  epsilon_ = value;
}

// optional bool halbit = 100;
inline bool Member::has_halbit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Member::set_has_halbit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Member::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Member::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Member::halbit() const {
  return halbit_;
}
inline void Member::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
}

// optional double halfloat = 101;
inline bool Member::has_halfloat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Member::set_has_halfloat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Member::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Member::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Member::halfloat() const {
  return halfloat_;
}
inline void Member::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
}

// optional sint32 hals32 = 102;
inline bool Member::has_hals32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Member::set_has_hals32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Member::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Member::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Member::hals32() const {
  return hals32_;
}
inline void Member::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
}

// optional uint32 halu32 = 103;
inline bool Member::has_halu32() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Member::set_has_halu32() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Member::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Member::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Member::halu32() const {
  return halu32_;
}
inline void Member::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
}

// -------------------------------------------------------------------

// Group

// optional string name = 20;
inline bool Group::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Group::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Group::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Group::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Group::name() const {
  return *name_;
}
inline void Group::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Group::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Group::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Group::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Group::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 handle = 25;
inline bool Group::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Group::handle() const {
  return handle_;
}
inline void Group::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
}

// optional sint32 id = 30;
inline bool Group::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Group::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Group::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Group::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Group::id() const {
  return id_;
}
inline void Group::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional sint32 userarg1 = 50;
inline bool Group::has_userarg1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Group::set_has_userarg1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Group::clear_has_userarg1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Group::clear_userarg1() {
  userarg1_ = 0;
  clear_has_userarg1();
}
inline ::google::protobuf::int32 Group::userarg1() const {
  return userarg1_;
}
inline void Group::set_userarg1(::google::protobuf::int32 value) {
  set_has_userarg1();
  userarg1_ = value;
}

// optional sint32 userarg2 = 60;
inline bool Group::has_userarg2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Group::set_has_userarg2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Group::clear_has_userarg2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Group::clear_userarg2() {
  userarg2_ = 0;
  clear_has_userarg2();
}
inline ::google::protobuf::int32 Group::userarg2() const {
  return userarg2_;
}
inline void Group::set_userarg2(::google::protobuf::int32 value) {
  set_has_userarg2();
  userarg2_ = value;
}

// optional sint32 serial = 70;
inline bool Group::has_serial() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Group::set_has_serial() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Group::clear_has_serial() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Group::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 Group::serial() const {
  return serial_;
}
inline void Group::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// repeated .Member member = 80;
inline int Group::member_size() const {
  return member_.size();
}
inline void Group::clear_member() {
  member_.Clear();
}
inline const ::Member& Group::member(int index) const {
  return member_.Get(index);
}
inline ::Member* Group::mutable_member(int index) {
  return member_.Mutable(index);
}
inline ::Member* Group::add_member() {
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Member >&
Group::member() const {
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::Member >*
Group::mutable_member() {
  return &member_;
}

// -------------------------------------------------------------------

// Object

// required .ObjectType type = 10;
inline bool Object::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ObjectType Object::type() const {
  return static_cast< ::ObjectType >(type_);
}
inline void Object::set_type(::ObjectType value) {
  assert(::ObjectType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Value value = 20;
inline bool Object::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object::clear_value() {
  if (value_ != NULL) value_->::Value::Clear();
  clear_has_value();
}
inline const ::Value& Object::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::Value* Object::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::Value;
  return value_;
}
inline ::Value* Object::release_value() {
  clear_has_value();
  ::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Object::set_allocated_value(::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// optional .Originator origin = 30;
inline bool Object::has_origin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Object::set_has_origin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Object::clear_has_origin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Object::clear_origin() {
  if (origin_ != NULL) origin_->::Originator::Clear();
  clear_has_origin();
}
inline const ::Originator& Object::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::Originator* Object::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::Originator;
  return origin_;
}
inline ::Originator* Object::release_origin() {
  clear_has_origin();
  ::Originator* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void Object::set_allocated_origin(::Originator* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// optional .Instance instance = 40;
inline bool Object::has_instance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Object::set_has_instance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Object::clear_has_instance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Object::clear_instance() {
  if (instance_ != NULL) instance_->::Instance::Clear();
  clear_has_instance();
}
inline const ::Instance& Object::instance() const {
  return instance_ != NULL ? *instance_ : *default_instance_->instance_;
}
inline ::Instance* Object::mutable_instance() {
  set_has_instance();
  if (instance_ == NULL) instance_ = new ::Instance;
  return instance_;
}
inline ::Instance* Object::release_instance() {
  clear_has_instance();
  ::Instance* temp = instance_;
  instance_ = NULL;
  return temp;
}
inline void Object::set_allocated_instance(::Instance* instance) {
  delete instance_;
  instance_ = instance;
  if (instance) {
    set_has_instance();
  } else {
    clear_has_instance();
  }
}

// optional .Pin pin = 100;
inline bool Object::has_pin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Object::set_has_pin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Object::clear_has_pin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Object::clear_pin() {
  if (pin_ != NULL) pin_->::Pin::Clear();
  clear_has_pin();
}
inline const ::Pin& Object::pin() const {
  return pin_ != NULL ? *pin_ : *default_instance_->pin_;
}
inline ::Pin* Object::mutable_pin() {
  set_has_pin();
  if (pin_ == NULL) pin_ = new ::Pin;
  return pin_;
}
inline ::Pin* Object::release_pin() {
  clear_has_pin();
  ::Pin* temp = pin_;
  pin_ = NULL;
  return temp;
}
inline void Object::set_allocated_pin(::Pin* pin) {
  delete pin_;
  pin_ = pin;
  if (pin) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
}

// optional .Signal signal = 110;
inline bool Object::has_signal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Object::set_has_signal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Object::clear_has_signal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Object::clear_signal() {
  if (signal_ != NULL) signal_->::Signal::Clear();
  clear_has_signal();
}
inline const ::Signal& Object::signal() const {
  return signal_ != NULL ? *signal_ : *default_instance_->signal_;
}
inline ::Signal* Object::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) signal_ = new ::Signal;
  return signal_;
}
inline ::Signal* Object::release_signal() {
  clear_has_signal();
  ::Signal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline void Object::set_allocated_signal(::Signal* signal) {
  delete signal_;
  signal_ = signal;
  if (signal) {
    set_has_signal();
  } else {
    clear_has_signal();
  }
}

// optional .Param param = 120;
inline bool Object::has_param() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Object::set_has_param() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Object::clear_has_param() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Object::clear_param() {
  if (param_ != NULL) param_->::Param::Clear();
  clear_has_param();
}
inline const ::Param& Object::param() const {
  return param_ != NULL ? *param_ : *default_instance_->param_;
}
inline ::Param* Object::mutable_param() {
  set_has_param();
  if (param_ == NULL) param_ = new ::Param;
  return param_;
}
inline ::Param* Object::release_param() {
  clear_has_param();
  ::Param* temp = param_;
  param_ = NULL;
  return temp;
}
inline void Object::set_allocated_param(::Param* param) {
  delete param_;
  param_ = param;
  if (param) {
    set_has_param();
  } else {
    clear_has_param();
  }
}

// optional .Thread thread = 130;
inline bool Object::has_thread() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Object::set_has_thread() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Object::clear_has_thread() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Object::clear_thread() {
  if (thread_ != NULL) thread_->::Thread::Clear();
  clear_has_thread();
}
inline const ::Thread& Object::thread() const {
  return thread_ != NULL ? *thread_ : *default_instance_->thread_;
}
inline ::Thread* Object::mutable_thread() {
  set_has_thread();
  if (thread_ == NULL) thread_ = new ::Thread;
  return thread_;
}
inline ::Thread* Object::release_thread() {
  clear_has_thread();
  ::Thread* temp = thread_;
  thread_ = NULL;
  return temp;
}
inline void Object::set_allocated_thread(::Thread* thread) {
  delete thread_;
  thread_ = thread;
  if (thread) {
    set_has_thread();
  } else {
    clear_has_thread();
  }
}

// optional .Component comp = 140;
inline bool Object::has_comp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Object::set_has_comp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Object::clear_has_comp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Object::clear_comp() {
  if (comp_ != NULL) comp_->::Component::Clear();
  clear_has_comp();
}
inline const ::Component& Object::comp() const {
  return comp_ != NULL ? *comp_ : *default_instance_->comp_;
}
inline ::Component* Object::mutable_comp() {
  set_has_comp();
  if (comp_ == NULL) comp_ = new ::Component;
  return comp_;
}
inline ::Component* Object::release_comp() {
  clear_has_comp();
  ::Component* temp = comp_;
  comp_ = NULL;
  return temp;
}
inline void Object::set_allocated_comp(::Component* comp) {
  delete comp_;
  comp_ = comp;
  if (comp) {
    set_has_comp();
  } else {
    clear_has_comp();
  }
}

// optional .Ring ring = 150;
inline bool Object::has_ring() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Object::set_has_ring() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Object::clear_has_ring() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Object::clear_ring() {
  if (ring_ != NULL) ring_->::Ring::Clear();
  clear_has_ring();
}
inline const ::Ring& Object::ring() const {
  return ring_ != NULL ? *ring_ : *default_instance_->ring_;
}
inline ::Ring* Object::mutable_ring() {
  set_has_ring();
  if (ring_ == NULL) ring_ = new ::Ring;
  return ring_;
}
inline ::Ring* Object::release_ring() {
  clear_has_ring();
  ::Ring* temp = ring_;
  ring_ = NULL;
  return temp;
}
inline void Object::set_allocated_ring(::Ring* ring) {
  delete ring_;
  ring_ = ring;
  if (ring) {
    set_has_ring();
  } else {
    clear_has_ring();
  }
}

// optional .Group group = 160;
inline bool Object::has_group() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Object::set_has_group() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Object::clear_has_group() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Object::clear_group() {
  if (group_ != NULL) group_->::Group::Clear();
  clear_has_group();
}
inline const ::Group& Object::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::Group* Object::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::Group;
  return group_;
}
inline ::Group* Object::release_group() {
  clear_has_group();
  ::Group* temp = group_;
  group_ = NULL;
  return temp;
}
inline void Object::set_allocated_group(::Group* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// optional .Member member = 170;
inline bool Object::has_member() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Object::set_has_member() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Object::clear_has_member() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Object::clear_member() {
  if (member_ != NULL) member_->::Member::Clear();
  clear_has_member();
}
inline const ::Member& Object::member() const {
  return member_ != NULL ? *member_ : *default_instance_->member_;
}
inline ::Member* Object::mutable_member() {
  set_has_member();
  if (member_ == NULL) member_ = new ::Member;
  return member_;
}
inline ::Member* Object::release_member() {
  clear_has_member();
  ::Member* temp = member_;
  member_ = NULL;
  return temp;
}
inline void Object::set_allocated_member(::Member* member) {
  delete member_;
  member_ = member;
  if (member) {
    set_has_member();
  } else {
    clear_has_member();
  }
}

// optional .Function function = 180;
inline bool Object::has_function() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Object::set_has_function() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Object::clear_has_function() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Object::clear_function() {
  if (function_ != NULL) function_->::Function::Clear();
  clear_has_function();
}
inline const ::Function& Object::function() const {
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::Function* Object::mutable_function() {
  set_has_function();
  if (function_ == NULL) function_ = new ::Function;
  return function_;
}
inline ::Function* Object::release_function() {
  clear_has_function();
  ::Function* temp = function_;
  function_ = NULL;
  return temp;
}
inline void Object::set_allocated_function(::Function* function) {
  delete function_;
  function_ = function;
  if (function) {
    set_has_function();
  } else {
    clear_has_function();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_object_2eproto__INCLUDED
