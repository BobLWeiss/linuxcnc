/* Generated by the protocol buffer compiler.  DO NOT EDIT! */

#ifndef PROTOBUF_C_motcmds_2eproto__INCLUDED
#define PROTOBUF_C_motcmds_2eproto__INCLUDED

#include <google/protobuf-c/protobuf-c.h>

PROTOBUF_C_BEGIN_DECLS

#include "emcclass.pb-c.h"

typedef struct _MotionCommand MotionCommand;


/* --- enums --- */

typedef enum _MotionType {
  MOTION_TYPE__EMC_MOTION_TYPE_TRAVERSE = 1,
  MOTION_TYPE__EMC_MOTION_TYPE_FEED = 2,
  MOTION_TYPE__EMC_MOTION_TYPE_ARC = 3,
  MOTION_TYPE__EMC_MOTION_TYPE_TOOLCHANGE = 4,
  MOTION_TYPE__EMC_MOTION_TYPE_PROBING = 5,
  MOTION_TYPE__EMC_MOTION_TYPE_INDEXROTARY = 6
    _PROTOBUF_C_FORCE_ENUM_TO_BE_INT_SIZE(MOTION_TYPE)
} MotionType;
typedef enum _CmdCodeT {
  CMD_CODE_T__EMCMOT_ABORT = 4000,
  CMD_CODE_T__EMCMOT_AXIS_ABORT = 4001,
  CMD_CODE_T__EMCMOT_ENABLE = 4002,
  CMD_CODE_T__EMCMOT_DISABLE = 4003,
  CMD_CODE_T__EMCMOT_ENABLE_AMPLIFIER = 4004,
  CMD_CODE_T__EMCMOT_DISABLE_AMPLIFIER = 4005,
  CMD_CODE_T__EMCMOT_ENABLE_WATCHDOG = 4006,
  CMD_CODE_T__EMCMOT_DISABLE_WATCHDOG = 4007,
  CMD_CODE_T__EMCMOT_ACTIVATE_JOINT = 4008,
  CMD_CODE_T__EMCMOT_DEACTIVATE_JOINT = 4009,
  CMD_CODE_T__EMCMOT_PAUSE = 4010,
  CMD_CODE_T__EMCMOT_RESUME = 4011,
  CMD_CODE_T__EMCMOT_STEP = 4012,
  CMD_CODE_T__EMCMOT_FREE = 4013,
  CMD_CODE_T__EMCMOT_COORD = 4014,
  CMD_CODE_T__EMCMOT_TELEOP = 4015,
  CMD_CODE_T__EMCMOT_SPINDLE_SCALE = 4016,
  CMD_CODE_T__EMCMOT_SS_ENABLE = 4017,
  CMD_CODE_T__EMCMOT_FEED_SCALE = 4018,
  CMD_CODE_T__EMCMOT_FS_ENABLE = 4019,
  CMD_CODE_T__EMCMOT_FH_ENABLE = 4020,
  CMD_CODE_T__EMCMOT_AF_ENABLE = 4021,
  CMD_CODE_T__EMCMOT_OVERRIDE_LIMITS = 4022,
  CMD_CODE_T__EMCMOT_HOME = 4023,
  CMD_CODE_T__EMCMOT_UNHOME = 4024,
  CMD_CODE_T__EMCMOT_JOG_CONT = 4025,
  CMD_CODE_T__EMCMOT_JOG_INCR = 4026,
  CMD_CODE_T__EMCMOT_JOG_ABS = 4027,
  CMD_CODE_T__EMCMOT_SET_LINE = 4028,
  CMD_CODE_T__EMCMOT_SET_CIRCLE = 4029,
  CMD_CODE_T__EMCMOT_SET_TELEOP_VECTOR = 4030,
  CMD_CODE_T__EMCMOT_CLEAR_PROBE_FLAGS = 4031,
  CMD_CODE_T__EMCMOT_PROBE = 4032,
  CMD_CODE_T__EMCMOT_RIGID_TAP = 4033,
  CMD_CODE_T__EMCMOT_SET_POSITION_LIMITS = 4034,
  CMD_CODE_T__EMCMOT_SET_BACKLASH = 4035,
  CMD_CODE_T__EMCMOT_SET_MIN_FERROR = 4036,
  CMD_CODE_T__EMCMOT_SET_MAX_FERROR = 4037,
  CMD_CODE_T__EMCMOT_SET_VEL = 4038,
  CMD_CODE_T__EMCMOT_SET_VEL_LIMIT = 4039,
  CMD_CODE_T__EMCMOT_SET_JOINT_VEL_LIMIT = 4040,
  CMD_CODE_T__EMCMOT_SET_JOINT_ACC_LIMIT = 4041,
  CMD_CODE_T__EMCMOT_SET_ACC = 4042,
  CMD_CODE_T__EMCMOT_SET_TERM_COND = 4043,
  CMD_CODE_T__EMCMOT_SET_NUM_AXES = 4044,
  CMD_CODE_T__EMCMOT_SET_WORLD_HOME = 4045,
  CMD_CODE_T__EMCMOT_SET_HOMING_PARAMS = 4046,
  CMD_CODE_T__EMCMOT_SET_DEBUG = 4047,
  CMD_CODE_T__EMCMOT_SET_DOUT = 4048,
  CMD_CODE_T__EMCMOT_SET_AOUT = 4049,
  CMD_CODE_T__EMCMOT_SET_SPINDLESYNC = 4050,
  CMD_CODE_T__EMCMOT_SPINDLE_ON = 4051,
  CMD_CODE_T__EMCMOT_SPINDLE_OFF = 4052,
  CMD_CODE_T__EMCMOT_SPINDLE_INCREASE = 4053,
  CMD_CODE_T__EMCMOT_SPINDLE_DECREASE = 4054,
  CMD_CODE_T__EMCMOT_SPINDLE_BRAKE_ENGAGE = 4055,
  CMD_CODE_T__EMCMOT_SPINDLE_BRAKE_RELEASE = 4056,
  CMD_CODE_T__EMCMOT_SET_MOTOR_OFFSET = 4057,
  CMD_CODE_T__EMCMOT_SET_JOINT_COMP = 4058,
  CMD_CODE_T__EMCMOT_SET_OFFSET = 4059
    _PROTOBUF_C_FORCE_ENUM_TO_BE_INT_SIZE(CMD_CODE_T)
} CmdCodeT;
typedef enum _CmdStatusT {
  CMD_STATUS_T__EMCMOT_COMMAND_OK = 0,
  CMD_STATUS_T__EMCMOT_COMMAND_UNKNOWN_COMMAND = 1,
  CMD_STATUS_T__EMCMOT_COMMAND_INVALID_COMMAND = 2,
  CMD_STATUS_T__EMCMOT_COMMAND_INVALID_PARAMS = 3,
  CMD_STATUS_T__EMCMOT_COMMAND_BAD_EXEC = 4
    _PROTOBUF_C_FORCE_ENUM_TO_BE_INT_SIZE(CMD_STATUS_T)
} CmdStatusT;

/* --- messages --- */

struct  _MotionCommand
{
  ProtobufCMessage base;
  CmdCodeT command;
  uint32_t commandnum;
  protobuf_c_boolean has_motor_offset;
  double motor_offset;
  protobuf_c_boolean has_maxlimit;
  double maxlimit;
  protobuf_c_boolean has_minlimit;
  double minlimit;
  EmcPose *pos;
  PmCartesian *center;
  PmCartesian *normal;
  protobuf_c_boolean has_turn;
  uint32_t turn;
  protobuf_c_boolean has_vel;
  double vel;
  protobuf_c_boolean has_ini_maxvel;
  double ini_maxvel;
  protobuf_c_boolean has_motion_type;
  MotionType motion_type;
  protobuf_c_boolean has_spindlesync;
  double spindlesync;
  protobuf_c_boolean has_acc;
  double acc;
  protobuf_c_boolean has_backlash;
  double backlash;
  protobuf_c_boolean has_id;
  uint32_t id;
  protobuf_c_boolean has_termcond;
  uint32_t termcond;
  protobuf_c_boolean has_tolerance;
  double tolerance;
  protobuf_c_boolean has_axis;
  uint32_t axis;
  protobuf_c_boolean has_scale;
  double scale;
  protobuf_c_boolean has_offset;
  double offset;
  protobuf_c_boolean has_home;
  double home;
  protobuf_c_boolean has_home_final_vel;
  double home_final_vel;
  protobuf_c_boolean has_search_vel;
  double search_vel;
  protobuf_c_boolean has_latch_vel;
  double latch_vel;
  protobuf_c_boolean has_flags;
  uint32_t flags;
  protobuf_c_boolean has_home_sequence;
  uint32_t home_sequence;
  protobuf_c_boolean has_volatile_home;
  uint32_t volatile_home;
  protobuf_c_boolean has_minferror;
  double minferror;
  protobuf_c_boolean has_maxferror;
  double maxferror;
  protobuf_c_boolean has_wdwait;
  uint32_t wdwait;
  protobuf_c_boolean has_debug;
  uint32_t debug;
  protobuf_c_boolean has_now;
  int32_t now;
  protobuf_c_boolean has_out;
  int32_t out;
  protobuf_c_boolean has_start;
  int32_t start;
  protobuf_c_boolean has_end;
  int32_t end;
  protobuf_c_boolean has_mode;
  int32_t mode;
  protobuf_c_boolean has_comp_nominal;
  double comp_nominal;
  protobuf_c_boolean has_comp_forward;
  double comp_forward;
  protobuf_c_boolean has_comp_reverse;
  double comp_reverse;
  protobuf_c_boolean has_probe_type;
  int32_t probe_type;
  EmcPose *tool_offset;
};
#define MOTION_COMMAND__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&motion_command__descriptor) \
    , 0, 0, 0,0, 0,0, 0,0, NULL, NULL, NULL, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, 0,0, NULL }


/* MotionCommand methods */
void   motion_command__init
                     (MotionCommand         *message);
size_t motion_command__get_packed_size
                     (const MotionCommand   *message);
size_t motion_command__pack
                     (const MotionCommand   *message,
                      uint8_t             *out);
size_t motion_command__pack_to_buffer
                     (const MotionCommand   *message,
                      ProtobufCBuffer     *buffer);
MotionCommand *
       motion_command__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   motion_command__free_unpacked
                     (MotionCommand *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*MotionCommand_Closure)
                 (const MotionCommand *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    motion_type__descriptor;
extern const ProtobufCEnumDescriptor    cmd_code_t__descriptor;
extern const ProtobufCEnumDescriptor    cmd_status_t__descriptor;
extern const ProtobufCMessageDescriptor motion_command__descriptor;

PROTOBUF_C_END_DECLS


#endif  /* PROTOBUF_motcmds_2eproto__INCLUDED */
