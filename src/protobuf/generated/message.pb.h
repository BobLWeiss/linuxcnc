// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "nanopb.pb.h"
#include "types.pb.h"
#include "object.pb.h"
#include "rtapi_message.pb.h"
#include "test.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class Command;
class Response;
class NmlMessage;
class Container;

// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CmdType op = 10;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 10;
  inline ::CmdType op() const;
  inline void set_op(::CmdType value);

  // optional int32 serial = 20;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 20;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);

  // optional .ReplyRequired rsvp = 30;
  inline bool has_rsvp() const;
  inline void clear_rsvp();
  static const int kRsvpFieldNumber = 30;
  inline ::ReplyRequired rsvp() const;
  inline void set_rsvp(::ReplyRequired value);

  // optional .Originator origin = 40;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 40;
  inline const ::Originator& origin() const;
  inline ::Originator* mutable_origin();
  inline ::Originator* release_origin();
  inline void set_allocated_origin(::Originator* origin);

  // repeated .Object args = 50;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 50;
  inline const ::Object& args(int index) const;
  inline ::Object* mutable_args(int index);
  inline ::Object* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Object >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Object >*
      mutable_args();

  // optional int32 timestamp = 60;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 60;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Command)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_rsvp();
  inline void clear_has_rsvp();
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int op_;
  ::google::protobuf::int32 serial_;
  ::Originator* origin_;
  int rsvp_;
  ::google::protobuf::int32 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::Object > args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RespType response = 5;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 5;
  inline ::RespType response() const;
  inline void set_response(::RespType value);

  // optional .CmdType in_reply_to = 10;
  inline bool has_in_reply_to() const;
  inline void clear_in_reply_to();
  static const int kInReplyToFieldNumber = 10;
  inline ::CmdType in_reply_to() const;
  inline void set_in_reply_to(::CmdType value);

  // optional int32 request_serial = 20;
  inline bool has_request_serial() const;
  inline void clear_request_serial();
  static const int kRequestSerialFieldNumber = 20;
  inline ::google::protobuf::int32 request_serial() const;
  inline void set_request_serial(::google::protobuf::int32 value);

  // optional .StatusType status = 25;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 25;
  inline ::StatusType status() const;
  inline void set_status(::StatusType value);

  // optional .Originator origin = 30;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 30;
  inline const ::Originator& origin() const;
  inline ::Originator* mutable_origin();
  inline ::Originator* release_origin();
  inline void set_allocated_origin(::Originator* origin);

  // optional int64 timestamp = 40;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 40;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string errormsg = 50;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrormsgFieldNumber = 50;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  inline void set_allocated_errormsg(::std::string* errormsg);

  // repeated .Object args = 60;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 60;
  inline const ::Object& args(int index) const;
  inline ::Object* mutable_args(int index);
  inline ::Object* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Object >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Object >*
      mutable_args();

  // repeated .Object failed_args = 70;
  inline int failed_args_size() const;
  inline void clear_failed_args();
  static const int kFailedArgsFieldNumber = 70;
  inline const ::Object& failed_args(int index) const;
  inline ::Object* mutable_failed_args(int index);
  inline ::Object* add_failed_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Object >&
      failed_args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Object >*
      mutable_failed_args();

  // @@protoc_insertion_point(class_scope:Response)
 private:
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_in_reply_to();
  inline void clear_has_in_reply_to();
  inline void set_has_request_serial();
  inline void clear_has_request_serial();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int response_;
  int in_reply_to_;
  ::google::protobuf::int32 request_serial_;
  int status_;
  ::Originator* origin_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* errormsg_;
  ::google::protobuf::RepeatedPtrField< ::Object > args_;
  ::google::protobuf::RepeatedPtrField< ::Object > failed_args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class NmlMessage : public ::google::protobuf::Message {
 public:
  NmlMessage();
  virtual ~NmlMessage();

  NmlMessage(const NmlMessage& from);

  inline NmlMessage& operator=(const NmlMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NmlMessage& default_instance();

  void Swap(NmlMessage* other);

  // implements Message ----------------------------------------------

  NmlMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NmlMessage& from);
  void MergeFrom(const NmlMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required bytes payload = 20;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 20;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:NmlMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* payload_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static NmlMessage* default_instance_;
};
// -------------------------------------------------------------------

class Container : public ::google::protobuf::Message {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  void Swap(Container* other);

  // implements Message ----------------------------------------------

  Container* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // required .MsgType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::MsgType type() const;
  inline void set_type(::MsgType value);

  // optional .Command command = 4;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 4;
  inline const ::Command& command() const;
  inline ::Command* mutable_command();
  inline ::Command* release_command();
  inline void set_allocated_command(::Command* command);

  // optional .Response response = 5;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 5;
  inline const ::Response& response() const;
  inline ::Response* mutable_response();
  inline ::Response* release_response();
  inline void set_allocated_response(::Response* response);

  // optional .RTAPI_Message rtapi_message = 6;
  inline bool has_rtapi_message() const;
  inline void clear_rtapi_message();
  static const int kRtapiMessageFieldNumber = 6;
  inline const ::RTAPI_Message& rtapi_message() const;
  inline ::RTAPI_Message* mutable_rtapi_message();
  inline ::RTAPI_Message* release_rtapi_message();
  inline void set_allocated_rtapi_message(::RTAPI_Message* rtapi_message);

  // optional bytes nml = 7;
  inline bool has_nml() const;
  inline void clear_nml();
  static const int kNmlFieldNumber = 7;
  inline const ::std::string& nml() const;
  inline void set_nml(const ::std::string& value);
  inline void set_nml(const char* value);
  inline void set_nml(const void* value, size_t size);
  inline ::std::string* mutable_nml();
  inline ::std::string* release_nml();
  inline void set_allocated_nml(::std::string* nml);

  // optional bytes motion = 8;
  inline bool has_motion() const;
  inline void clear_motion();
  static const int kMotionFieldNumber = 8;
  inline const ::std::string& motion() const;
  inline void set_motion(const ::std::string& value);
  inline void set_motion(const char* value);
  inline void set_motion(const void* value, size_t size);
  inline ::std::string* mutable_motion();
  inline ::std::string* release_motion();
  inline void set_allocated_motion(::std::string* motion);

  // optional bytes wou = 9;
  inline bool has_wou() const;
  inline void clear_wou();
  static const int kWouFieldNumber = 9;
  inline const ::std::string& wou() const;
  inline void set_wou(const ::std::string& value);
  inline void set_wou(const char* value);
  inline void set_wou(const void* value, size_t size);
  inline ::std::string* mutable_wou();
  inline ::std::string* release_wou();
  inline void set_allocated_wou(::std::string* wou);

  // optional bytes syslog = 10;
  inline bool has_syslog() const;
  inline void clear_syslog();
  static const int kSyslogFieldNumber = 10;
  inline const ::std::string& syslog() const;
  inline void set_syslog(const ::std::string& value);
  inline void set_syslog(const char* value);
  inline void set_syslog(const void* value, size_t size);
  inline ::std::string* mutable_syslog();
  inline ::std::string* release_syslog();
  inline void set_allocated_syslog(::std::string* syslog);

  // optional string ascii = 100;
  inline bool has_ascii() const;
  inline void clear_ascii();
  static const int kAsciiFieldNumber = 100;
  inline const ::std::string& ascii() const;
  inline void set_ascii(const ::std::string& value);
  inline void set_ascii(const char* value);
  inline void set_ascii(const char* value, size_t size);
  inline ::std::string* mutable_ascii();
  inline ::std::string* release_ascii();
  inline void set_allocated_ascii(::std::string* ascii);

  // optional bytes unicode = 101;
  inline bool has_unicode() const;
  inline void clear_unicode();
  static const int kUnicodeFieldNumber = 101;
  inline const ::std::string& unicode() const;
  inline void set_unicode(const ::std::string& value);
  inline void set_unicode(const char* value);
  inline void set_unicode(const void* value, size_t size);
  inline ::std::string* mutable_unicode();
  inline ::std::string* release_unicode();
  inline void set_allocated_unicode(::std::string* unicode);

  // optional string gcode = 102;
  inline bool has_gcode() const;
  inline void clear_gcode();
  static const int kGcodeFieldNumber = 102;
  inline const ::std::string& gcode() const;
  inline void set_gcode(const ::std::string& value);
  inline void set_gcode(const char* value);
  inline void set_gcode(const char* value, size_t size);
  inline ::std::string* mutable_gcode();
  inline ::std::string* release_gcode();
  inline void set_allocated_gcode(::std::string* gcode);

  // optional string python = 103;
  inline bool has_python() const;
  inline void clear_python();
  static const int kPythonFieldNumber = 103;
  inline const ::std::string& python() const;
  inline void set_python(const ::std::string& value);
  inline void set_python(const char* value);
  inline void set_python(const char* value, size_t size);
  inline ::std::string* mutable_python();
  inline ::std::string* release_python();
  inline void set_allocated_python(::std::string* python);

  // optional bytes pickle = 104;
  inline bool has_pickle() const;
  inline void clear_pickle();
  static const int kPickleFieldNumber = 104;
  inline const ::std::string& pickle() const;
  inline void set_pickle(const ::std::string& value);
  inline void set_pickle(const char* value);
  inline void set_pickle(const void* value, size_t size);
  inline ::std::string* mutable_pickle();
  inline ::std::string* release_pickle();
  inline void set_allocated_pickle(::std::string* pickle);

  // optional string tcl = 105;
  inline bool has_tcl() const;
  inline void clear_tcl();
  static const int kTclFieldNumber = 105;
  inline const ::std::string& tcl() const;
  inline void set_tcl(const ::std::string& value);
  inline void set_tcl(const char* value);
  inline void set_tcl(const char* value, size_t size);
  inline ::std::string* mutable_tcl();
  inline ::std::string* release_tcl();
  inline void set_allocated_tcl(::std::string* tcl);

  // optional string xml = 106;
  inline bool has_xml() const;
  inline void clear_xml();
  static const int kXmlFieldNumber = 106;
  inline const ::std::string& xml() const;
  inline void set_xml(const ::std::string& value);
  inline void set_xml(const char* value);
  inline void set_xml(const char* value, size_t size);
  inline ::std::string* mutable_xml();
  inline ::std::string* release_xml();
  inline void set_allocated_xml(::std::string* xml);

  // optional string json = 107;
  inline bool has_json() const;
  inline void clear_json();
  static const int kJsonFieldNumber = 107;
  inline const ::std::string& json() const;
  inline void set_json(const ::std::string& value);
  inline void set_json(const char* value);
  inline void set_json(const char* value, size_t size);
  inline ::std::string* mutable_json();
  inline ::std::string* release_json();
  inline void set_allocated_json(::std::string* json);

  // optional bytes jpeg = 108;
  inline bool has_jpeg() const;
  inline void clear_jpeg();
  static const int kJpegFieldNumber = 108;
  inline const ::std::string& jpeg() const;
  inline void set_jpeg(const ::std::string& value);
  inline void set_jpeg(const char* value);
  inline void set_jpeg(const void* value, size_t size);
  inline ::std::string* mutable_jpeg();
  inline ::std::string* release_jpeg();
  inline void set_allocated_jpeg(::std::string* jpeg);

  // optional bytes png = 109;
  inline bool has_png() const;
  inline void clear_png();
  static const int kPngFieldNumber = 109;
  inline const ::std::string& png() const;
  inline void set_png(const ::std::string& value);
  inline void set_png(const char* value);
  inline void set_png(const void* value, size_t size);
  inline ::std::string* mutable_png();
  inline ::std::string* release_png();
  inline void set_allocated_png(::std::string* png);

  // optional bytes tiff = 110;
  inline bool has_tiff() const;
  inline void clear_tiff();
  static const int kTiffFieldNumber = 110;
  inline const ::std::string& tiff() const;
  inline void set_tiff(const ::std::string& value);
  inline void set_tiff(const char* value);
  inline void set_tiff(const void* value, size_t size);
  inline ::std::string* mutable_tiff();
  inline ::std::string* release_tiff();
  inline void set_allocated_tiff(::std::string* tiff);

  // optional bytes postscript = 111;
  inline bool has_postscript() const;
  inline void clear_postscript();
  static const int kPostscriptFieldNumber = 111;
  inline const ::std::string& postscript() const;
  inline void set_postscript(const ::std::string& value);
  inline void set_postscript(const char* value);
  inline void set_postscript(const void* value, size_t size);
  inline ::std::string* mutable_postscript();
  inline ::std::string* release_postscript();
  inline void set_allocated_postscript(::std::string* postscript);

  // optional bytes svg = 112;
  inline bool has_svg() const;
  inline void clear_svg();
  static const int kSvgFieldNumber = 112;
  inline const ::std::string& svg() const;
  inline void set_svg(const ::std::string& value);
  inline void set_svg(const char* value);
  inline void set_svg(const void* value, size_t size);
  inline ::std::string* mutable_svg();
  inline ::std::string* release_svg();
  inline void set_allocated_svg(::std::string* svg);

  // optional bytes pru_firmware = 2048;
  inline bool has_pru_firmware() const;
  inline void clear_pru_firmware();
  static const int kPruFirmwareFieldNumber = 2048;
  inline const ::std::string& pru_firmware() const;
  inline void set_pru_firmware(const ::std::string& value);
  inline void set_pru_firmware(const char* value);
  inline void set_pru_firmware(const void* value, size_t size);
  inline ::std::string* mutable_pru_firmware();
  inline ::std::string* release_pru_firmware();
  inline void set_allocated_pru_firmware(::std::string* pru_firmware);

  // optional bytes mesa_5i20_firmware = 3000;
  inline bool has_mesa_5i20_firmware() const;
  inline void clear_mesa_5i20_firmware();
  static const int kMesa5I20FirmwareFieldNumber = 3000;
  inline const ::std::string& mesa_5i20_firmware() const;
  inline void set_mesa_5i20_firmware(const ::std::string& value);
  inline void set_mesa_5i20_firmware(const char* value);
  inline void set_mesa_5i20_firmware(const void* value, size_t size);
  inline ::std::string* mutable_mesa_5i20_firmware();
  inline ::std::string* release_mesa_5i20_firmware();
  inline void set_allocated_mesa_5i20_firmware(::std::string* mesa_5i20_firmware);

  // optional .Test1 test1 = 5001;
  inline bool has_test1() const;
  inline void clear_test1();
  static const int kTest1FieldNumber = 5001;
  inline const ::Test1& test1() const;
  inline ::Test1* mutable_test1();
  inline ::Test1* release_test1();
  inline void set_allocated_test1(::Test1* test1);

  // optional .Test2 test2 = 5002;
  inline bool has_test2() const;
  inline void clear_test2();
  static const int kTest2FieldNumber = 5002;
  inline const ::Test2& test2() const;
  inline ::Test2* mutable_test2();
  inline ::Test2* release_test2();
  inline void set_allocated_test2(::Test2* test2);

  // optional .Test3 test3 = 5003;
  inline bool has_test3() const;
  inline void clear_test3();
  static const int kTest3FieldNumber = 5003;
  inline const ::Test3& test3() const;
  inline ::Test3* mutable_test3();
  inline ::Test3* release_test3();
  inline void set_allocated_test3(::Test3* test3);

  // @@protoc_insertion_point(class_scope:Container)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_rtapi_message();
  inline void clear_has_rtapi_message();
  inline void set_has_nml();
  inline void clear_has_nml();
  inline void set_has_motion();
  inline void clear_has_motion();
  inline void set_has_wou();
  inline void clear_has_wou();
  inline void set_has_syslog();
  inline void clear_has_syslog();
  inline void set_has_ascii();
  inline void clear_has_ascii();
  inline void set_has_unicode();
  inline void clear_has_unicode();
  inline void set_has_gcode();
  inline void clear_has_gcode();
  inline void set_has_python();
  inline void clear_has_python();
  inline void set_has_pickle();
  inline void clear_has_pickle();
  inline void set_has_tcl();
  inline void clear_has_tcl();
  inline void set_has_xml();
  inline void clear_has_xml();
  inline void set_has_json();
  inline void clear_has_json();
  inline void set_has_jpeg();
  inline void clear_has_jpeg();
  inline void set_has_png();
  inline void clear_has_png();
  inline void set_has_tiff();
  inline void clear_has_tiff();
  inline void set_has_postscript();
  inline void clear_has_postscript();
  inline void set_has_svg();
  inline void clear_has_svg();
  inline void set_has_pru_firmware();
  inline void clear_has_pru_firmware();
  inline void set_has_mesa_5i20_firmware();
  inline void clear_has_mesa_5i20_firmware();
  inline void set_has_test1();
  inline void clear_has_test1();
  inline void set_has_test2();
  inline void clear_has_test2();
  inline void set_has_test3();
  inline void clear_has_test3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 length_;
  int type_;
  ::Command* command_;
  ::Response* response_;
  ::RTAPI_Message* rtapi_message_;
  ::std::string* nml_;
  ::std::string* motion_;
  ::std::string* wou_;
  ::std::string* syslog_;
  ::std::string* ascii_;
  ::std::string* unicode_;
  ::std::string* gcode_;
  ::std::string* python_;
  ::std::string* pickle_;
  ::std::string* tcl_;
  ::std::string* xml_;
  ::std::string* json_;
  ::std::string* jpeg_;
  ::std::string* png_;
  ::std::string* tiff_;
  ::std::string* postscript_;
  ::std::string* svg_;
  ::std::string* pru_firmware_;
  ::std::string* mesa_5i20_firmware_;
  ::Test1* test1_;
  ::Test2* test2_;
  ::Test3* test3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];

  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();

  void InitAsDefaultInstance();
  static Container* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// required .CmdType op = 10;
inline bool Command::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_op() {
  op_ = 10;
  clear_has_op();
}
inline ::CmdType Command::op() const {
  return static_cast< ::CmdType >(op_);
}
inline void Command::set_op(::CmdType value) {
  assert(::CmdType_IsValid(value));
  set_has_op();
  op_ = value;
}

// optional int32 serial = 20;
inline bool Command::has_serial() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_serial() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_serial() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 Command::serial() const {
  return serial_;
}
inline void Command::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// optional .ReplyRequired rsvp = 30;
inline bool Command::has_rsvp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_rsvp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_rsvp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_rsvp() {
  rsvp_ = 0;
  clear_has_rsvp();
}
inline ::ReplyRequired Command::rsvp() const {
  return static_cast< ::ReplyRequired >(rsvp_);
}
inline void Command::set_rsvp(::ReplyRequired value) {
  assert(::ReplyRequired_IsValid(value));
  set_has_rsvp();
  rsvp_ = value;
}

// optional .Originator origin = 40;
inline bool Command::has_origin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_origin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_origin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_origin() {
  if (origin_ != NULL) origin_->::Originator::Clear();
  clear_has_origin();
}
inline const ::Originator& Command::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::Originator* Command::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::Originator;
  return origin_;
}
inline ::Originator* Command::release_origin() {
  clear_has_origin();
  ::Originator* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void Command::set_allocated_origin(::Originator* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// repeated .Object args = 50;
inline int Command::args_size() const {
  return args_.size();
}
inline void Command::clear_args() {
  args_.Clear();
}
inline const ::Object& Command::args(int index) const {
  return args_.Get(index);
}
inline ::Object* Command::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::Object* Command::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Object >&
Command::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Object >*
Command::mutable_args() {
  return &args_;
}

// optional int32 timestamp = 60;
inline bool Command::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 Command::timestamp() const {
  return timestamp_;
}
inline void Command::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Response

// required .RespType response = 5;
inline bool Response::has_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_response() {
  response_ = 10;
  clear_has_response();
}
inline ::RespType Response::response() const {
  return static_cast< ::RespType >(response_);
}
inline void Response::set_response(::RespType value) {
  assert(::RespType_IsValid(value));
  set_has_response();
  response_ = value;
}

// optional .CmdType in_reply_to = 10;
inline bool Response::has_in_reply_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_in_reply_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_in_reply_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_in_reply_to() {
  in_reply_to_ = 10;
  clear_has_in_reply_to();
}
inline ::CmdType Response::in_reply_to() const {
  return static_cast< ::CmdType >(in_reply_to_);
}
inline void Response::set_in_reply_to(::CmdType value) {
  assert(::CmdType_IsValid(value));
  set_has_in_reply_to();
  in_reply_to_ = value;
}

// optional int32 request_serial = 20;
inline bool Response::has_request_serial() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_request_serial() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_request_serial() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_request_serial() {
  request_serial_ = 0;
  clear_has_request_serial();
}
inline ::google::protobuf::int32 Response::request_serial() const {
  return request_serial_;
}
inline void Response::set_request_serial(::google::protobuf::int32 value) {
  set_has_request_serial();
  request_serial_ = value;
}

// optional .StatusType status = 25;
inline bool Response::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::StatusType Response::status() const {
  return static_cast< ::StatusType >(status_);
}
inline void Response::set_status(::StatusType value) {
  assert(::StatusType_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .Originator origin = 30;
inline bool Response::has_origin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_origin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_origin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_origin() {
  if (origin_ != NULL) origin_->::Originator::Clear();
  clear_has_origin();
}
inline const ::Originator& Response::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::Originator* Response::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::Originator;
  return origin_;
}
inline ::Originator* Response::release_origin() {
  clear_has_origin();
  ::Originator* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void Response::set_allocated_origin(::Originator* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// optional int64 timestamp = 40;
inline bool Response::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Response::timestamp() const {
  return timestamp_;
}
inline void Response::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string errormsg = 50;
inline bool Response::has_errormsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_errormsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& Response::errormsg() const {
  return *errormsg_;
}
inline void Response::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void Response::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void Response::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Response::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* Response::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Response::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    delete errormsg_;
  }
  if (errormsg) {
    set_has_errormsg();
    errormsg_ = errormsg;
  } else {
    clear_has_errormsg();
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Object args = 60;
inline int Response::args_size() const {
  return args_.size();
}
inline void Response::clear_args() {
  args_.Clear();
}
inline const ::Object& Response::args(int index) const {
  return args_.Get(index);
}
inline ::Object* Response::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::Object* Response::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Object >&
Response::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Object >*
Response::mutable_args() {
  return &args_;
}

// repeated .Object failed_args = 70;
inline int Response::failed_args_size() const {
  return failed_args_.size();
}
inline void Response::clear_failed_args() {
  failed_args_.Clear();
}
inline const ::Object& Response::failed_args(int index) const {
  return failed_args_.Get(index);
}
inline ::Object* Response::mutable_failed_args(int index) {
  return failed_args_.Mutable(index);
}
inline ::Object* Response::add_failed_args() {
  return failed_args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Object >&
Response::failed_args() const {
  return failed_args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Object >*
Response::mutable_failed_args() {
  return &failed_args_;
}

// -------------------------------------------------------------------

// NmlMessage

// required int32 type = 10;
inline bool NmlMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NmlMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NmlMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NmlMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 NmlMessage::type() const {
  return type_;
}
inline void NmlMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required bytes payload = 20;
inline bool NmlMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NmlMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NmlMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NmlMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& NmlMessage::payload() const {
  return *payload_;
}
inline void NmlMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void NmlMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void NmlMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NmlMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* NmlMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NmlMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Container

// required fixed32 length = 1;
inline bool Container::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 Container::length() const {
  return length_;
}
inline void Container::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// required .MsgType type = 2;
inline bool Container::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_type() {
  type_ = 4;
  clear_has_type();
}
inline ::MsgType Container::type() const {
  return static_cast< ::MsgType >(type_);
}
inline void Container::set_type(::MsgType value) {
  assert(::MsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Command command = 4;
inline bool Container::has_command() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Container::set_has_command() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Container::clear_has_command() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Container::clear_command() {
  if (command_ != NULL) command_->::Command::Clear();
  clear_has_command();
}
inline const ::Command& Container::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::Command* Container::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::Command;
  return command_;
}
inline ::Command* Container::release_command() {
  clear_has_command();
  ::Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Container::set_allocated_command(::Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// optional .Response response = 5;
inline bool Container::has_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Container::set_has_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Container::clear_has_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Container::clear_response() {
  if (response_ != NULL) response_->::Response::Clear();
  clear_has_response();
}
inline const ::Response& Container::response() const {
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::Response* Container::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::Response;
  return response_;
}
inline ::Response* Container::release_response() {
  clear_has_response();
  ::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void Container::set_allocated_response(::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
}

// optional .RTAPI_Message rtapi_message = 6;
inline bool Container::has_rtapi_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Container::set_has_rtapi_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Container::clear_has_rtapi_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Container::clear_rtapi_message() {
  if (rtapi_message_ != NULL) rtapi_message_->::RTAPI_Message::Clear();
  clear_has_rtapi_message();
}
inline const ::RTAPI_Message& Container::rtapi_message() const {
  return rtapi_message_ != NULL ? *rtapi_message_ : *default_instance_->rtapi_message_;
}
inline ::RTAPI_Message* Container::mutable_rtapi_message() {
  set_has_rtapi_message();
  if (rtapi_message_ == NULL) rtapi_message_ = new ::RTAPI_Message;
  return rtapi_message_;
}
inline ::RTAPI_Message* Container::release_rtapi_message() {
  clear_has_rtapi_message();
  ::RTAPI_Message* temp = rtapi_message_;
  rtapi_message_ = NULL;
  return temp;
}
inline void Container::set_allocated_rtapi_message(::RTAPI_Message* rtapi_message) {
  delete rtapi_message_;
  rtapi_message_ = rtapi_message;
  if (rtapi_message) {
    set_has_rtapi_message();
  } else {
    clear_has_rtapi_message();
  }
}

// optional bytes nml = 7;
inline bool Container::has_nml() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Container::set_has_nml() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Container::clear_has_nml() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Container::clear_nml() {
  if (nml_ != &::google::protobuf::internal::kEmptyString) {
    nml_->clear();
  }
  clear_has_nml();
}
inline const ::std::string& Container::nml() const {
  return *nml_;
}
inline void Container::set_nml(const ::std::string& value) {
  set_has_nml();
  if (nml_ == &::google::protobuf::internal::kEmptyString) {
    nml_ = new ::std::string;
  }
  nml_->assign(value);
}
inline void Container::set_nml(const char* value) {
  set_has_nml();
  if (nml_ == &::google::protobuf::internal::kEmptyString) {
    nml_ = new ::std::string;
  }
  nml_->assign(value);
}
inline void Container::set_nml(const void* value, size_t size) {
  set_has_nml();
  if (nml_ == &::google::protobuf::internal::kEmptyString) {
    nml_ = new ::std::string;
  }
  nml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_nml() {
  set_has_nml();
  if (nml_ == &::google::protobuf::internal::kEmptyString) {
    nml_ = new ::std::string;
  }
  return nml_;
}
inline ::std::string* Container::release_nml() {
  clear_has_nml();
  if (nml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nml_;
    nml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_nml(::std::string* nml) {
  if (nml_ != &::google::protobuf::internal::kEmptyString) {
    delete nml_;
  }
  if (nml) {
    set_has_nml();
    nml_ = nml;
  } else {
    clear_has_nml();
    nml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes motion = 8;
inline bool Container::has_motion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Container::set_has_motion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Container::clear_has_motion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Container::clear_motion() {
  if (motion_ != &::google::protobuf::internal::kEmptyString) {
    motion_->clear();
  }
  clear_has_motion();
}
inline const ::std::string& Container::motion() const {
  return *motion_;
}
inline void Container::set_motion(const ::std::string& value) {
  set_has_motion();
  if (motion_ == &::google::protobuf::internal::kEmptyString) {
    motion_ = new ::std::string;
  }
  motion_->assign(value);
}
inline void Container::set_motion(const char* value) {
  set_has_motion();
  if (motion_ == &::google::protobuf::internal::kEmptyString) {
    motion_ = new ::std::string;
  }
  motion_->assign(value);
}
inline void Container::set_motion(const void* value, size_t size) {
  set_has_motion();
  if (motion_ == &::google::protobuf::internal::kEmptyString) {
    motion_ = new ::std::string;
  }
  motion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_motion() {
  set_has_motion();
  if (motion_ == &::google::protobuf::internal::kEmptyString) {
    motion_ = new ::std::string;
  }
  return motion_;
}
inline ::std::string* Container::release_motion() {
  clear_has_motion();
  if (motion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = motion_;
    motion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_motion(::std::string* motion) {
  if (motion_ != &::google::protobuf::internal::kEmptyString) {
    delete motion_;
  }
  if (motion) {
    set_has_motion();
    motion_ = motion;
  } else {
    clear_has_motion();
    motion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes wou = 9;
inline bool Container::has_wou() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Container::set_has_wou() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Container::clear_has_wou() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Container::clear_wou() {
  if (wou_ != &::google::protobuf::internal::kEmptyString) {
    wou_->clear();
  }
  clear_has_wou();
}
inline const ::std::string& Container::wou() const {
  return *wou_;
}
inline void Container::set_wou(const ::std::string& value) {
  set_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    wou_ = new ::std::string;
  }
  wou_->assign(value);
}
inline void Container::set_wou(const char* value) {
  set_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    wou_ = new ::std::string;
  }
  wou_->assign(value);
}
inline void Container::set_wou(const void* value, size_t size) {
  set_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    wou_ = new ::std::string;
  }
  wou_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_wou() {
  set_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    wou_ = new ::std::string;
  }
  return wou_;
}
inline ::std::string* Container::release_wou() {
  clear_has_wou();
  if (wou_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wou_;
    wou_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_wou(::std::string* wou) {
  if (wou_ != &::google::protobuf::internal::kEmptyString) {
    delete wou_;
  }
  if (wou) {
    set_has_wou();
    wou_ = wou;
  } else {
    clear_has_wou();
    wou_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes syslog = 10;
inline bool Container::has_syslog() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Container::set_has_syslog() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Container::clear_has_syslog() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Container::clear_syslog() {
  if (syslog_ != &::google::protobuf::internal::kEmptyString) {
    syslog_->clear();
  }
  clear_has_syslog();
}
inline const ::std::string& Container::syslog() const {
  return *syslog_;
}
inline void Container::set_syslog(const ::std::string& value) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(value);
}
inline void Container::set_syslog(const char* value) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(value);
}
inline void Container::set_syslog(const void* value, size_t size) {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  syslog_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_syslog() {
  set_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    syslog_ = new ::std::string;
  }
  return syslog_;
}
inline ::std::string* Container::release_syslog() {
  clear_has_syslog();
  if (syslog_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = syslog_;
    syslog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_syslog(::std::string* syslog) {
  if (syslog_ != &::google::protobuf::internal::kEmptyString) {
    delete syslog_;
  }
  if (syslog) {
    set_has_syslog();
    syslog_ = syslog;
  } else {
    clear_has_syslog();
    syslog_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ascii = 100;
inline bool Container::has_ascii() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Container::set_has_ascii() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Container::clear_has_ascii() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Container::clear_ascii() {
  if (ascii_ != &::google::protobuf::internal::kEmptyString) {
    ascii_->clear();
  }
  clear_has_ascii();
}
inline const ::std::string& Container::ascii() const {
  return *ascii_;
}
inline void Container::set_ascii(const ::std::string& value) {
  set_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    ascii_ = new ::std::string;
  }
  ascii_->assign(value);
}
inline void Container::set_ascii(const char* value) {
  set_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    ascii_ = new ::std::string;
  }
  ascii_->assign(value);
}
inline void Container::set_ascii(const char* value, size_t size) {
  set_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    ascii_ = new ::std::string;
  }
  ascii_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_ascii() {
  set_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    ascii_ = new ::std::string;
  }
  return ascii_;
}
inline ::std::string* Container::release_ascii() {
  clear_has_ascii();
  if (ascii_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ascii_;
    ascii_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_ascii(::std::string* ascii) {
  if (ascii_ != &::google::protobuf::internal::kEmptyString) {
    delete ascii_;
  }
  if (ascii) {
    set_has_ascii();
    ascii_ = ascii;
  } else {
    clear_has_ascii();
    ascii_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes unicode = 101;
inline bool Container::has_unicode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Container::set_has_unicode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Container::clear_has_unicode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Container::clear_unicode() {
  if (unicode_ != &::google::protobuf::internal::kEmptyString) {
    unicode_->clear();
  }
  clear_has_unicode();
}
inline const ::std::string& Container::unicode() const {
  return *unicode_;
}
inline void Container::set_unicode(const ::std::string& value) {
  set_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    unicode_ = new ::std::string;
  }
  unicode_->assign(value);
}
inline void Container::set_unicode(const char* value) {
  set_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    unicode_ = new ::std::string;
  }
  unicode_->assign(value);
}
inline void Container::set_unicode(const void* value, size_t size) {
  set_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    unicode_ = new ::std::string;
  }
  unicode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_unicode() {
  set_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    unicode_ = new ::std::string;
  }
  return unicode_;
}
inline ::std::string* Container::release_unicode() {
  clear_has_unicode();
  if (unicode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unicode_;
    unicode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_unicode(::std::string* unicode) {
  if (unicode_ != &::google::protobuf::internal::kEmptyString) {
    delete unicode_;
  }
  if (unicode) {
    set_has_unicode();
    unicode_ = unicode;
  } else {
    clear_has_unicode();
    unicode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string gcode = 102;
inline bool Container::has_gcode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Container::set_has_gcode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Container::clear_has_gcode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Container::clear_gcode() {
  if (gcode_ != &::google::protobuf::internal::kEmptyString) {
    gcode_->clear();
  }
  clear_has_gcode();
}
inline const ::std::string& Container::gcode() const {
  return *gcode_;
}
inline void Container::set_gcode(const ::std::string& value) {
  set_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    gcode_ = new ::std::string;
  }
  gcode_->assign(value);
}
inline void Container::set_gcode(const char* value) {
  set_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    gcode_ = new ::std::string;
  }
  gcode_->assign(value);
}
inline void Container::set_gcode(const char* value, size_t size) {
  set_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    gcode_ = new ::std::string;
  }
  gcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_gcode() {
  set_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    gcode_ = new ::std::string;
  }
  return gcode_;
}
inline ::std::string* Container::release_gcode() {
  clear_has_gcode();
  if (gcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gcode_;
    gcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_gcode(::std::string* gcode) {
  if (gcode_ != &::google::protobuf::internal::kEmptyString) {
    delete gcode_;
  }
  if (gcode) {
    set_has_gcode();
    gcode_ = gcode;
  } else {
    clear_has_gcode();
    gcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string python = 103;
inline bool Container::has_python() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Container::set_has_python() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Container::clear_has_python() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Container::clear_python() {
  if (python_ != &::google::protobuf::internal::kEmptyString) {
    python_->clear();
  }
  clear_has_python();
}
inline const ::std::string& Container::python() const {
  return *python_;
}
inline void Container::set_python(const ::std::string& value) {
  set_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    python_ = new ::std::string;
  }
  python_->assign(value);
}
inline void Container::set_python(const char* value) {
  set_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    python_ = new ::std::string;
  }
  python_->assign(value);
}
inline void Container::set_python(const char* value, size_t size) {
  set_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    python_ = new ::std::string;
  }
  python_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_python() {
  set_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    python_ = new ::std::string;
  }
  return python_;
}
inline ::std::string* Container::release_python() {
  clear_has_python();
  if (python_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = python_;
    python_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_python(::std::string* python) {
  if (python_ != &::google::protobuf::internal::kEmptyString) {
    delete python_;
  }
  if (python) {
    set_has_python();
    python_ = python;
  } else {
    clear_has_python();
    python_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pickle = 104;
inline bool Container::has_pickle() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Container::set_has_pickle() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Container::clear_has_pickle() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Container::clear_pickle() {
  if (pickle_ != &::google::protobuf::internal::kEmptyString) {
    pickle_->clear();
  }
  clear_has_pickle();
}
inline const ::std::string& Container::pickle() const {
  return *pickle_;
}
inline void Container::set_pickle(const ::std::string& value) {
  set_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    pickle_ = new ::std::string;
  }
  pickle_->assign(value);
}
inline void Container::set_pickle(const char* value) {
  set_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    pickle_ = new ::std::string;
  }
  pickle_->assign(value);
}
inline void Container::set_pickle(const void* value, size_t size) {
  set_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    pickle_ = new ::std::string;
  }
  pickle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_pickle() {
  set_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    pickle_ = new ::std::string;
  }
  return pickle_;
}
inline ::std::string* Container::release_pickle() {
  clear_has_pickle();
  if (pickle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pickle_;
    pickle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_pickle(::std::string* pickle) {
  if (pickle_ != &::google::protobuf::internal::kEmptyString) {
    delete pickle_;
  }
  if (pickle) {
    set_has_pickle();
    pickle_ = pickle;
  } else {
    clear_has_pickle();
    pickle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tcl = 105;
inline bool Container::has_tcl() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Container::set_has_tcl() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Container::clear_has_tcl() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Container::clear_tcl() {
  if (tcl_ != &::google::protobuf::internal::kEmptyString) {
    tcl_->clear();
  }
  clear_has_tcl();
}
inline const ::std::string& Container::tcl() const {
  return *tcl_;
}
inline void Container::set_tcl(const ::std::string& value) {
  set_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    tcl_ = new ::std::string;
  }
  tcl_->assign(value);
}
inline void Container::set_tcl(const char* value) {
  set_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    tcl_ = new ::std::string;
  }
  tcl_->assign(value);
}
inline void Container::set_tcl(const char* value, size_t size) {
  set_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    tcl_ = new ::std::string;
  }
  tcl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_tcl() {
  set_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    tcl_ = new ::std::string;
  }
  return tcl_;
}
inline ::std::string* Container::release_tcl() {
  clear_has_tcl();
  if (tcl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tcl_;
    tcl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_tcl(::std::string* tcl) {
  if (tcl_ != &::google::protobuf::internal::kEmptyString) {
    delete tcl_;
  }
  if (tcl) {
    set_has_tcl();
    tcl_ = tcl;
  } else {
    clear_has_tcl();
    tcl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string xml = 106;
inline bool Container::has_xml() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Container::set_has_xml() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Container::clear_has_xml() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Container::clear_xml() {
  if (xml_ != &::google::protobuf::internal::kEmptyString) {
    xml_->clear();
  }
  clear_has_xml();
}
inline const ::std::string& Container::xml() const {
  return *xml_;
}
inline void Container::set_xml(const ::std::string& value) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(value);
}
inline void Container::set_xml(const char* value) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(value);
}
inline void Container::set_xml(const char* value, size_t size) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_xml() {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  return xml_;
}
inline ::std::string* Container::release_xml() {
  clear_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xml_;
    xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_xml(::std::string* xml) {
  if (xml_ != &::google::protobuf::internal::kEmptyString) {
    delete xml_;
  }
  if (xml) {
    set_has_xml();
    xml_ = xml;
  } else {
    clear_has_xml();
    xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string json = 107;
inline bool Container::has_json() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Container::set_has_json() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Container::clear_has_json() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Container::clear_json() {
  if (json_ != &::google::protobuf::internal::kEmptyString) {
    json_->clear();
  }
  clear_has_json();
}
inline const ::std::string& Container::json() const {
  return *json_;
}
inline void Container::set_json(const ::std::string& value) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    json_ = new ::std::string;
  }
  json_->assign(value);
}
inline void Container::set_json(const char* value) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    json_ = new ::std::string;
  }
  json_->assign(value);
}
inline void Container::set_json(const char* value, size_t size) {
  set_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    json_ = new ::std::string;
  }
  json_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_json() {
  set_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    json_ = new ::std::string;
  }
  return json_;
}
inline ::std::string* Container::release_json() {
  clear_has_json();
  if (json_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = json_;
    json_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_json(::std::string* json) {
  if (json_ != &::google::protobuf::internal::kEmptyString) {
    delete json_;
  }
  if (json) {
    set_has_json();
    json_ = json;
  } else {
    clear_has_json();
    json_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes jpeg = 108;
inline bool Container::has_jpeg() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Container::set_has_jpeg() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Container::clear_has_jpeg() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Container::clear_jpeg() {
  if (jpeg_ != &::google::protobuf::internal::kEmptyString) {
    jpeg_->clear();
  }
  clear_has_jpeg();
}
inline const ::std::string& Container::jpeg() const {
  return *jpeg_;
}
inline void Container::set_jpeg(const ::std::string& value) {
  set_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    jpeg_ = new ::std::string;
  }
  jpeg_->assign(value);
}
inline void Container::set_jpeg(const char* value) {
  set_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    jpeg_ = new ::std::string;
  }
  jpeg_->assign(value);
}
inline void Container::set_jpeg(const void* value, size_t size) {
  set_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    jpeg_ = new ::std::string;
  }
  jpeg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_jpeg() {
  set_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    jpeg_ = new ::std::string;
  }
  return jpeg_;
}
inline ::std::string* Container::release_jpeg() {
  clear_has_jpeg();
  if (jpeg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jpeg_;
    jpeg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_jpeg(::std::string* jpeg) {
  if (jpeg_ != &::google::protobuf::internal::kEmptyString) {
    delete jpeg_;
  }
  if (jpeg) {
    set_has_jpeg();
    jpeg_ = jpeg;
  } else {
    clear_has_jpeg();
    jpeg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes png = 109;
inline bool Container::has_png() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Container::set_has_png() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Container::clear_has_png() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Container::clear_png() {
  if (png_ != &::google::protobuf::internal::kEmptyString) {
    png_->clear();
  }
  clear_has_png();
}
inline const ::std::string& Container::png() const {
  return *png_;
}
inline void Container::set_png(const ::std::string& value) {
  set_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    png_ = new ::std::string;
  }
  png_->assign(value);
}
inline void Container::set_png(const char* value) {
  set_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    png_ = new ::std::string;
  }
  png_->assign(value);
}
inline void Container::set_png(const void* value, size_t size) {
  set_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    png_ = new ::std::string;
  }
  png_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_png() {
  set_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    png_ = new ::std::string;
  }
  return png_;
}
inline ::std::string* Container::release_png() {
  clear_has_png();
  if (png_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = png_;
    png_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_png(::std::string* png) {
  if (png_ != &::google::protobuf::internal::kEmptyString) {
    delete png_;
  }
  if (png) {
    set_has_png();
    png_ = png;
  } else {
    clear_has_png();
    png_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes tiff = 110;
inline bool Container::has_tiff() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Container::set_has_tiff() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Container::clear_has_tiff() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Container::clear_tiff() {
  if (tiff_ != &::google::protobuf::internal::kEmptyString) {
    tiff_->clear();
  }
  clear_has_tiff();
}
inline const ::std::string& Container::tiff() const {
  return *tiff_;
}
inline void Container::set_tiff(const ::std::string& value) {
  set_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    tiff_ = new ::std::string;
  }
  tiff_->assign(value);
}
inline void Container::set_tiff(const char* value) {
  set_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    tiff_ = new ::std::string;
  }
  tiff_->assign(value);
}
inline void Container::set_tiff(const void* value, size_t size) {
  set_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    tiff_ = new ::std::string;
  }
  tiff_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_tiff() {
  set_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    tiff_ = new ::std::string;
  }
  return tiff_;
}
inline ::std::string* Container::release_tiff() {
  clear_has_tiff();
  if (tiff_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tiff_;
    tiff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_tiff(::std::string* tiff) {
  if (tiff_ != &::google::protobuf::internal::kEmptyString) {
    delete tiff_;
  }
  if (tiff) {
    set_has_tiff();
    tiff_ = tiff;
  } else {
    clear_has_tiff();
    tiff_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes postscript = 111;
inline bool Container::has_postscript() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Container::set_has_postscript() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Container::clear_has_postscript() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Container::clear_postscript() {
  if (postscript_ != &::google::protobuf::internal::kEmptyString) {
    postscript_->clear();
  }
  clear_has_postscript();
}
inline const ::std::string& Container::postscript() const {
  return *postscript_;
}
inline void Container::set_postscript(const ::std::string& value) {
  set_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    postscript_ = new ::std::string;
  }
  postscript_->assign(value);
}
inline void Container::set_postscript(const char* value) {
  set_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    postscript_ = new ::std::string;
  }
  postscript_->assign(value);
}
inline void Container::set_postscript(const void* value, size_t size) {
  set_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    postscript_ = new ::std::string;
  }
  postscript_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_postscript() {
  set_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    postscript_ = new ::std::string;
  }
  return postscript_;
}
inline ::std::string* Container::release_postscript() {
  clear_has_postscript();
  if (postscript_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postscript_;
    postscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_postscript(::std::string* postscript) {
  if (postscript_ != &::google::protobuf::internal::kEmptyString) {
    delete postscript_;
  }
  if (postscript) {
    set_has_postscript();
    postscript_ = postscript;
  } else {
    clear_has_postscript();
    postscript_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes svg = 112;
inline bool Container::has_svg() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Container::set_has_svg() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Container::clear_has_svg() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Container::clear_svg() {
  if (svg_ != &::google::protobuf::internal::kEmptyString) {
    svg_->clear();
  }
  clear_has_svg();
}
inline const ::std::string& Container::svg() const {
  return *svg_;
}
inline void Container::set_svg(const ::std::string& value) {
  set_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    svg_ = new ::std::string;
  }
  svg_->assign(value);
}
inline void Container::set_svg(const char* value) {
  set_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    svg_ = new ::std::string;
  }
  svg_->assign(value);
}
inline void Container::set_svg(const void* value, size_t size) {
  set_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    svg_ = new ::std::string;
  }
  svg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_svg() {
  set_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    svg_ = new ::std::string;
  }
  return svg_;
}
inline ::std::string* Container::release_svg() {
  clear_has_svg();
  if (svg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = svg_;
    svg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_svg(::std::string* svg) {
  if (svg_ != &::google::protobuf::internal::kEmptyString) {
    delete svg_;
  }
  if (svg) {
    set_has_svg();
    svg_ = svg;
  } else {
    clear_has_svg();
    svg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pru_firmware = 2048;
inline bool Container::has_pru_firmware() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Container::set_has_pru_firmware() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Container::clear_has_pru_firmware() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Container::clear_pru_firmware() {
  if (pru_firmware_ != &::google::protobuf::internal::kEmptyString) {
    pru_firmware_->clear();
  }
  clear_has_pru_firmware();
}
inline const ::std::string& Container::pru_firmware() const {
  return *pru_firmware_;
}
inline void Container::set_pru_firmware(const ::std::string& value) {
  set_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    pru_firmware_ = new ::std::string;
  }
  pru_firmware_->assign(value);
}
inline void Container::set_pru_firmware(const char* value) {
  set_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    pru_firmware_ = new ::std::string;
  }
  pru_firmware_->assign(value);
}
inline void Container::set_pru_firmware(const void* value, size_t size) {
  set_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    pru_firmware_ = new ::std::string;
  }
  pru_firmware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_pru_firmware() {
  set_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    pru_firmware_ = new ::std::string;
  }
  return pru_firmware_;
}
inline ::std::string* Container::release_pru_firmware() {
  clear_has_pru_firmware();
  if (pru_firmware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pru_firmware_;
    pru_firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_pru_firmware(::std::string* pru_firmware) {
  if (pru_firmware_ != &::google::protobuf::internal::kEmptyString) {
    delete pru_firmware_;
  }
  if (pru_firmware) {
    set_has_pru_firmware();
    pru_firmware_ = pru_firmware;
  } else {
    clear_has_pru_firmware();
    pru_firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes mesa_5i20_firmware = 3000;
inline bool Container::has_mesa_5i20_firmware() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Container::set_has_mesa_5i20_firmware() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Container::clear_has_mesa_5i20_firmware() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Container::clear_mesa_5i20_firmware() {
  if (mesa_5i20_firmware_ != &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_->clear();
  }
  clear_has_mesa_5i20_firmware();
}
inline const ::std::string& Container::mesa_5i20_firmware() const {
  return *mesa_5i20_firmware_;
}
inline void Container::set_mesa_5i20_firmware(const ::std::string& value) {
  set_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_ = new ::std::string;
  }
  mesa_5i20_firmware_->assign(value);
}
inline void Container::set_mesa_5i20_firmware(const char* value) {
  set_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_ = new ::std::string;
  }
  mesa_5i20_firmware_->assign(value);
}
inline void Container::set_mesa_5i20_firmware(const void* value, size_t size) {
  set_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_ = new ::std::string;
  }
  mesa_5i20_firmware_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Container::mutable_mesa_5i20_firmware() {
  set_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    mesa_5i20_firmware_ = new ::std::string;
  }
  return mesa_5i20_firmware_;
}
inline ::std::string* Container::release_mesa_5i20_firmware() {
  clear_has_mesa_5i20_firmware();
  if (mesa_5i20_firmware_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mesa_5i20_firmware_;
    mesa_5i20_firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Container::set_allocated_mesa_5i20_firmware(::std::string* mesa_5i20_firmware) {
  if (mesa_5i20_firmware_ != &::google::protobuf::internal::kEmptyString) {
    delete mesa_5i20_firmware_;
  }
  if (mesa_5i20_firmware) {
    set_has_mesa_5i20_firmware();
    mesa_5i20_firmware_ = mesa_5i20_firmware;
  } else {
    clear_has_mesa_5i20_firmware();
    mesa_5i20_firmware_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Test1 test1 = 5001;
inline bool Container::has_test1() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Container::set_has_test1() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Container::clear_has_test1() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Container::clear_test1() {
  if (test1_ != NULL) test1_->::Test1::Clear();
  clear_has_test1();
}
inline const ::Test1& Container::test1() const {
  return test1_ != NULL ? *test1_ : *default_instance_->test1_;
}
inline ::Test1* Container::mutable_test1() {
  set_has_test1();
  if (test1_ == NULL) test1_ = new ::Test1;
  return test1_;
}
inline ::Test1* Container::release_test1() {
  clear_has_test1();
  ::Test1* temp = test1_;
  test1_ = NULL;
  return temp;
}
inline void Container::set_allocated_test1(::Test1* test1) {
  delete test1_;
  test1_ = test1;
  if (test1) {
    set_has_test1();
  } else {
    clear_has_test1();
  }
}

// optional .Test2 test2 = 5002;
inline bool Container::has_test2() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Container::set_has_test2() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Container::clear_has_test2() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Container::clear_test2() {
  if (test2_ != NULL) test2_->::Test2::Clear();
  clear_has_test2();
}
inline const ::Test2& Container::test2() const {
  return test2_ != NULL ? *test2_ : *default_instance_->test2_;
}
inline ::Test2* Container::mutable_test2() {
  set_has_test2();
  if (test2_ == NULL) test2_ = new ::Test2;
  return test2_;
}
inline ::Test2* Container::release_test2() {
  clear_has_test2();
  ::Test2* temp = test2_;
  test2_ = NULL;
  return temp;
}
inline void Container::set_allocated_test2(::Test2* test2) {
  delete test2_;
  test2_ = test2;
  if (test2) {
    set_has_test2();
  } else {
    clear_has_test2();
  }
}

// optional .Test3 test3 = 5003;
inline bool Container::has_test3() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Container::set_has_test3() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Container::clear_has_test3() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Container::clear_test3() {
  if (test3_ != NULL) test3_->::Test3::Clear();
  clear_has_test3();
}
inline const ::Test3& Container::test3() const {
  return test3_ != NULL ? *test3_ : *default_instance_->test3_;
}
inline ::Test3* Container::mutable_test3() {
  set_has_test3();
  if (test3_ == NULL) test3_ = new ::Test3;
  return test3_;
}
inline ::Test3* Container::release_test3() {
  clear_has_test3();
  ::Test3* temp = test3_;
  test3_ = NULL;
  return temp;
}
inline void Container::set_allocated_test3(::Test3* test3) {
  delete test3_;
  test3_ = test3;
  if (test3) {
    set_has_test3();
  } else {
    clear_has_test3();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
