component pbring;

pin out u32 underrun   "number of failed attempts to read a new command";
pin out u32 overrun    "number of response ring overruns";
pin out u32 received   "number of commands received";
pin out u32 encodefail "number of message encode fails";
pin out u32 decodefail "number of messages decode fails";

function _;

option singleton yes;
option rtapi_app no;

license "GPLv2 or later";
;;

#include "hal_priv.h"
#include "hal_ring.h"	        /* ringbuffer declarations */

// the nanopb library and compile message definitions are brought in once
// by 'halcmd loadrt nanopb'

#include <protobuf/pb-linuxcnc.h>
#include <protobuf/nanopb/pb_decode.h>
#include <protobuf/nanopb/pb_encode.h>

#include <protobuf/generated/types.npb.h>
#include <protobuf/generated/value.npb.h>
#include <protobuf/generated/object.npb.h>
#include <protobuf/generated/message.npb.h>
#include <protobuf/generated/rtapi_message.npb.h>

static char *command = "command";
RTAPI_MP_STRING(command,  "name of command ring");
static int csize = 4096;
RTAPI_MP_INT(csize, "size of command ring");
static char *response = "response";
RTAPI_MP_STRING(response,  "name of response ring");
static int rsize = 4096;
RTAPI_MP_INT(rsize, "size of response ring");

static ringbuffer_t command_rb, response_rb;
static char *mod = "pbring";

static int decode_msg(void *buf, int size, Container *container)
{
    pb_istream_t stream;

    // asm("int $3"); // trap into gdb

    stream = pb_istream_from_buffer((void *) buf, size);
    if (!pb_decode(&stream, Container_fields, container)) {
	decodefail++;
	rtapi_print_msg(RTAPI_MSG_ERR, "%s: pb_decode(container) failed: '%s'\n",
			mod, PB_GET_ERROR(&stream));
	return -1;
    }
    /* switch (encoding) { */
    /* case MsgEncoding_ENC_PROTOBUF: */
    /* 	switch (typ) { */

    /* 	case MsgType_MT_COMMAND: */

    /* 	    rtapi_print_msg(RTAPI_MSG_ERR,"type=%d serial=%d rsvp=%d \n", */
    /* 			    typ, command->serial, command->rsvp ); */

    /* 	    break; */
    /* 	default: */
    /* 	    rtapi_print_msg(RTAPI_MSG_ERR, "%s: handle_msg - unknown type %d\n",  */
    /* 			mod, typ); */
    /* 	    return -1;	     */
    /* 	} */
    /* 	break; */

    /* case MsgEncoding_ENC_ASCII_STRING: */
    /* 	rtapi_print_msg(RTAPI_MSG_ERR, "%s: ASCII message length %d,type %d: '%.*s'\n",  */
    /* 			mod, length, typ, length, (char *) &h->payload ); */
    /* 	return 1; // dont response to this message type */
    /* 	break; */

    /* default: */
    /* 	rtapi_print_msg(RTAPI_MSG_ERR, "%s: handle_msg - unknown encoding %d\n",  */
    /* 			mod, encoding); */
    /* 	return -1; */
    /* } */
    /* if (length != (size - sizeof(message_header_t))) { */
    /* 	rtapi_print_msg(RTAPI_MSG_WARN,  */
    /* 			"%s: hdr length=%d  and size=%d inconsistent\n",  */
    /* 			mod, length, size); */
    /* } */
    return 0;
}

static int send_response(int type, int serial)
{
    /* Response response = {StatusType_DONE, type, serial, -1, 0, {{0}}}; */
    /* uint8_t buffer[512]; */
    /* message_header_t *h = (void *) buffer; */
    /* pb_ostream_t stream = pb_ostream_from_buffer((void *)&h->payload,  */
    /* 						 sizeof(buffer) -  */
    /* 						 sizeof(message_header_t)); */
    /* if (pb_encode(&stream, Response_fields, &response)) { */
    /* 	h->length = htonl(stream.bytes_written); */
    /* 	h->encoding = htons(MsgEncoding_ENC_PROTOBUF); */
    /* 	h->type = htons(MsgType_MT_RESPONSE); */

    /* 	if (hal_record_write(&response_rb, h,  */
    /* 			   stream.bytes_written +  */
    /* 			   sizeof(message_header_t))) */
    /* 	    overrun++; */
    /*     return 0;  */
    /* } else { */
    /* 	rtapi_print_msg(RTAPI_MSG_ERR, "%s: pb_endode(response) failed\n",mod);  */
    /* 	encodefail++; */
    /*     return 1;  */
    /* } */
}

FUNCTION(_) {
    int cmdsize = rtapi_record_next_size(&command_rb);
    void *cmdbuffer;
    Container container;

    if (cmdsize < 0) {
	// command ring empty
	underrun++;
	return;
    }
    cmdbuffer = rtapi_record_next(&command_rb);
    if (!decode_msg(cmdbuffer, cmdsize, &container)) {
	// reasonable processing here

	// echo back selected fields
	// send_response(MsgType_MT_COMMAND, command.serial);
    }
    rtapi_record_shift(&command_rb);
    received++;
}

static int create_or_attach(const char *name, int size, ringbuffer_t * rb)
{
    int retval;

    // for messaging with protobuf, use record mode
    // default mode 0 = record mode
    if ((retval = hal_ring_new(name, size, 0, comp_id, 0))) {
	if (retval == -EEXIST) {
	    rtapi_print_msg(RTAPI_MSG_INFO,
			    "%s: using existing ring '%s'\n", mod, name);
	} else {
	    rtapi_print_msg(RTAPI_MSG_ERR,
			    "%s: failed to create new ring %s\n", mod, name);
	    return -1;
	}
    }
    if ((retval = hal_ring_attach(name, rb, comp_id))) {
	rtapi_print_msg(RTAPI_MSG_ERR,
			"%s: hal_ring_attach(%s) failed - %d\n",
			mod, command, retval);
	return -1;
    }
    return 0;
}

int rtapi_app_main(void)
{
    int retval;

    if ((comp_id = hal_init(mod)) < 0) {
	rtapi_print_msg(RTAPI_MSG_ERR,
			"%s: ERROR: hal_init(%s) failed: %d\n",
			mod, mod, comp_id);
	return -1;
    }
    if (create_or_attach(command, csize, &command_rb))
	return -1;
    if (create_or_attach(response, rsize, &response_rb))
	return -1;

    command_rb.header->reader = comp_id;
    response_rb.header->writer = comp_id;
    if ((retval = export(mod, 0))) {
	rtapi_print_msg(RTAPI_MSG_ERR,
			"%s: ERROR: export(%s) failed: %d\n",
			mod, mod, retval);
	return -1;
    }
    hal_ready(comp_id);
    return 0;
}

void rtapi_app_exit(void)
{
    int retval;

    if ((retval = hal_ring_detach(command, comp_id)))
	rtapi_print_msg(RTAPI_MSG_ERR,
			"%s: hal_ring_detach(%s) failed: %d\n",
			mod, command, retval);
    if ((retval = hal_ring_detach(response, comp_id)))
	rtapi_print_msg(RTAPI_MSG_ERR,
			"%s: hal_ring_detach(%s) failed: %d\n",
			mod, response, retval);
    hal_exit(comp_id);
}
