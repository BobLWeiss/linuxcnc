
I've pused zerocopy operations write_start and write_end. Datacopy write is
implemented on top of them. They pass sanity checks but should be tested

---

For instance, for me 'generations' are a new concept, what is it?
Generation is a number of records that were 'taken' from ring - it increments on each
successfull read operation (ring_shift) and guards iterator from pointing to invalid area
that was already cleared.

int ring_write(ringbuffer_t *ring, const void * data, size_t size);  <---- understood

Not understood, what do these do?

	int ring_write_start(ringbuffer_t *ring, void ** data, size_t size);
	int ring_write_end(ringbuffer_t *ring, void * data, size_t size);
Best example is ring_write itself - it's just a wrapper around theese two zerocopy functions.
First requests pointer to write block of size 'size'. Second one confirms that data is written
probably with smaller size.

what is that meant to be? abandoned idea or missing body of function?

	int ring_init_file(ringbuffer_t *ring, size_t size, int fd);
I've deleted it from ring.c as it was not in good shape but forgotten to kill one from header.

I assume this is history because no body?

	// Bad design :(
	struct iovec ring_next_iovec(ringbuffer_t *ring);
iovec idea was bad from the beginning :( Should be killed.

Those are used internally by ring_dump; shouldnt they be replaced by ring_read then?

	// Wrappers, not needed
	const void * ring_next(ringbuffer_t *ring);
	ring_size_t ring_next_size(ringbuffer_t *ring);
Theese two are now obsolete and if you don't need them they should be removed.

Here is very basic python example (it was not commited):

run as:
LD_LIBRARY_PATH=. python example.py

	#!/usr/bin/env python

	import ring

	r = ring.Ring(1024)

	r.write('xxx', 3)
	r.write('yyy', 3)
	r.write('zzz', 3)

	i = ring.RingIter(r)
	for _ in xrange(3):
		print i.read()
		print i.shift()

	i = ring.RingIter(r)
	assert(str(i.read()) == 'xxx')

Generations:

it seems this is a read transaction concept, a ring_shift bumps generation -
what is it supposed to mean? I am guessing: it means: ring was read to a
certain point and it has meaning only to iterators? Am I right to assume that
within a peek loop the generation is supposed to be constant; if not, somebody
else read a record while we were iterating?
Yes. All we need to know that current record that iterator tries to read is not
yet removed.

If that is the case, I would assume the usage of iterator is like so:

ring_t ring;
ringiter_t iter;
void *data;
size_t size;
int retval;
int recno = 0;

while (ring_iter_init(&ring, &iter)); // I hope this _does_ terminate ;)
If you are not lucky and there as _very_ fast reader and _very_ fast writer...

do {
	retval = ring_iter_read(&iter, &data, size_t &size);

	if (retval == EINVAL) {
		// somebody read the ring while we were iterating?
		// error message or what?
Somebody read ring faster then we can :(
		break;
	} else {
		// successful peek at record n
		recno++;
		ring_iter_read(....);
	}
	retval = ring_iter_shift(&iter);

	if (retval == EINVAL) {
		// what does retval == EAGAIN mean here - we're at the end?
Same - somebody killed iterator by reading ahead it's position.
		break;
	}
}

						Pavel