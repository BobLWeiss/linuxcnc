#! /bin/bash
#
# @configure_input@ 
# on @DATE@
#

export LANG=C
sysconfdir=@sysconfdir@
RUN_IN_PLACE=@RUN_IN_PLACE@


# wait for a list of pids to all exit
anywait(){
    for pid in "$@"; do
        while kill -0 "$pid" >/dev/null 2>&1 ; do
            sleep 0.5
        done
    done
}

find_module_path() {
    # look for a kernel module
    #
    # MODPATH set in rtapi.conf; may contain multiple dirs (an
    # exception for RTAI of course)
    #
    # any module paths that are symlinks are resolved to their real names
    local module=${1}${KMODULE_EXT}

    # userland threads pick up shmdrv.ko from shmdrv, not $FLAVOR
    if test $BUILD_SYS = user-dso; then
	local modflavor=shmdrv
    else
	local modflavor=$FLAVOR
    fi

    # search for module
    for path in $MODPATH; do
	for subpath in $path/$modflavor/$KERNEL_VERS $path/$modflavor $path; do
	    if test -e $subpath/$module; then
 		echo $(readlink -m $subpath/$module)
		break
	    fi
	done
    done
}

CheckKernel() {
    # Be sure required modules for the running kernel are available
    if test $BUILD_SYS = user-dso; then
	# Userland threads: insist on shmdrv if USE_SHMDRV=yes
	if test $USE_SHMDRV = yes -a -z "`find_module_path shmdrv`"; then
	    echo "Error:  USE_SHMDRV=yes in rtapi.conf, but unable to find
		shmdrv module in '$MODPATH'" >&2
	    exit 1
	fi
    else # BUILD_SYS = kbuild
	if test -z "`find_module_path rtapi`"; then
	    echo "Unable to find rtapi module in '$MODPATH'" >&2
	    exit 1
	fi
    fi
}

LoadConfig(){
    if [ "$RUN_IN_PLACE" = yes ]; then
        RTAPICONF=
        # check in the LinuxCNC scripts directory
        # get the canonical name of this script's directory
        SCRIPT_DIR=$(readlink -f $(dirname ${0}))
        # now look for rtapi.conf there
        if [ -f $SCRIPT_DIR/rtapi.conf ] ; then
            RTAPICONF=$SCRIPT_DIR/rtapi.conf
        fi
    else
        if [ -f $sysconfdir/linuxcnc/rtapi.conf ]; then
                RTAPICONF=$sysconfdir/linuxcnc/rtapi.conf
        fi
    fi
    if [ -z "$RTAPICONF" ] ; then
	echo "Missing rtapi.conf.  Check your installation." >&2
	exit 1
    fi
    # FIXME move this to rtapi.conf
    INSMOD="@INSMOD@"
    RMMOD="@RMMOD@"
    LSMOD="@LSMOD@"
    FUSER="@FUSER@"

    # Import the config
    source $RTAPICONF

    # Generate list of module paths for loading and unloading
    # lists contain RTOS modules plus RTAPI and HAL
    # unload list is in reverse order
    MODULES_LOAD=
    MODULES_UNLOAD=
    KMODULE_EXT=$MODULE_EXT
    # FIXME: 'flavor' binary returns .so for [RTAPI] module extension;
    # until the shmdrv case is represented better, hardcode kernel
    # module extension to .ko
    test $BUILD_SYS = user-dso && KMODULE_EXT=.ko
    for MOD in $MODULES; do
	MOD_PATH=`find_module_path $MOD`

	if test -n "$MOD_PATH"; then
            MODULES_LOAD="$MODULES_LOAD $MOD_PATH"
            MODULES_UNLOAD="$(basename $MOD_PATH $KMODULE_EXT) $MODULES_UNLOAD"
	else # MOD_PATH empty
	    if test $BUILD_SYS = kbuild; then
		echo "module $MOD not found; aborting" >&2
		exit 1
	    fi
	fi
    done
}

CheckStatus(){
    case $FLAVOR in
    posix|xenomai|rt-preempt)
         if [ -z "$($PIDOF rtapi:${INSTANCE})" ]; then
            exit 1
        else
            exit 0
        fi ;;
    *)
        # check loaded/unloaded status of modules
        unset NOTLOADED
        for MOD in $MODULES_UNLOAD ; do
            if @LSMOD@ | awk '{print $1}' | grep -x $MOD >/dev/null ; then
                echo "$MOD is loaded"
            else
                echo "$MOD is not loaded"
                NOTLOADED=NOT
            fi
        done
        if [ -z $NOTLOADED ]; then
            exit 0
        else
            exit 1
        fi
    esac
}

CheckMem(){
# check for user space processes using shared memory
    if [ -e /dev/mbuff ] ; then
	# device file exists, check for processes using it
	if $FUSER -s /dev/mbuff 2>/dev/null; then
	    # at least one process is using it
	    echo "ERROR:  Can't remove RTLinux modules, kill the following process(es) first"
	    $FUSER -v /dev/mbuff
	    exit 1
	fi
    elif [ -e /dev/rtai_shm ] ; then
	# device file exists, check for processes using it
	if $FUSER -s /dev/rtai_shm 2>/dev/null; then
	    # at least one process is using it
	    echo "ERROR:  Can't remove RTAI modules, kill the following process(es) first"
	    $FUSER -v /dev/rtai_shm
	    exit 1
	fi
    fi
}

Load(){
    CheckKernel

    # when not running shmdrv, perform shm + instance checks and cleanups
    #
    # FIXME:  how to do these for shmdrv?
    if test $BUILD_SYS = 'user-dso' -a $USE_SHMDRV = no; then
        # check for instance running
	# this is the case if the global segment exists
        # and any processes exist which have it attached
	GLOBALSEG=`printf '/dev/shm/linuxcnc-%d-%2.2d154711' $INSTANCE $INSTANCE` 
	if fuser $GLOBALSEG >/dev/null 2>&1 ; then
	    echo instance $INSTANCE already running!
	    exit 1
	fi

	# check for any leftover shm keys from aborted previous sessions
	INSTKEY=`printf 'linuxcnc-%d-' $INSTANCE` 
	SHMKEYS=`ls /dev/shm/${INSTKEY}* >/dev/null 2>&1`

	if [ "$SHMKEYS" != "" ]  ; then
	    echo "warning: leftover shared memory segments detected - removing: " $SHMKEYS
	    rm  -f  "$SHMKEYS" >/dev/null 2>&1
	fi
    fi

    # load kernel modules, including shmdrv for userland
    for MOD in $MODULES_LOAD; do
	# if loading rtapi.ko, tack on parameters
	if ! test ${MOD/rtapi.ko/} = $MOD; then
	    $INSMOD $MOD hal_size=$HAL_SIZE rtapi_instance=$INSTANCE \
		rt_msg_level=$DEBUG user_msg_level=$DEBUG $NAME_CMD 
	else
	    $INSMOD $MOD || return $?
	    # sleep a moment to let shmdrv initialize
	    test ${MOD%/shmdrv.ko} = ${MOD} || sleep .5
	fi
    done

    if test $BUILD_SYS = user-dso; then
        # run rtapi_app for userland
	if [ "$DEBUG" != "" ] ; then
	    rtapi_app --instance=$INSTANCE $NAME_CMD \
		--rtmsglevel=$DEBUG \
		--usrmsglevel=$DEBUG \
		--halsize=$HAL_SIZE 
	else
	    rtapi_app --instance $INSTANCE $NAME_CMD \
		--halsize=$HAL_SIZE \
		--rtmsglevel=$DEBUG \
		--usrmsglevel=$DEBUG 2>&1 >/dev/null  
        fi

    else  # BUILD_SYS = 'kbuild'
	# help debugging startup issues for kthreads
        if [ "$DEBUG" != "" ] && [ -w /proc/rtapi/debug ] ; then
            echo "$DEBUG" > /proc/rtapi/debug
        fi
    fi

    # the rtapi_msgd logging demon will wait in the foreground
    # until the HAL data segment exists, confirming the RT stack
    # is fully setup by rtapi_app, and only then disconnect into the
    # background. This closes a race condition where clients
    # like halcmd might try to attach the HAL data segment before
    # rtapi_app got around to creating it.

    rtapi_msgd --instance=$INSTANCE
}

CheckLoaded(){
    # this abomination is needed because udev sometimes doesn't
    # have the device ready for us in time.

    # If the shmdrv module isn't needed, skip checks
    if test "${MODULES/shmdrv${KMODULE_EXT}/}" = "${MODULES}"; then
	# no shmdrv module
	return
    fi

    SHM_DEV=/dev/shmdrv
    n=0
    while [ $n -lt 100 ]; do
        [ -w $SHM_DEV ] && return 0
        echo "." 1>&2
        sleep .1
        n=$(($n+1))
    done
    echo "Can't write to $SHM_DEV - aborting" 1>&2
    exit 1
}



Unload(){
    CheckKernel
    if test $BUILD_SYS = user-dso; then
	if [ "$DEBUG" != "" ] ; then
            rtapi_app --instance=$INSTANCE exit 
	else
            rtapi_app --instance=$INSTANCE exit            >/dev/null 2>&1
        fi

	# wait until rtapi_msgd has vanished. This assures
	# that the last user of the global data segment has vanished,
	# making sure an immediate restart of realtime does not find
	# shm segments still hanging around. The only realistic scenario
	# which could trigger this is runtests.
	MSGD_PID=`pidof msgd:$INSTANCE`
	if [ "$MSGD_PID" != "" ] ; then
	    kill $MSGD_PID
	    anywait $MSGD_PID
	fi

	# remove any linuxcnc-specific POSIX shm segments if they exist
	# see src/rtapi/rtapi_shmkeys.h: SHM_FMT
	INSTKEY=`printf 'linuxcnc-%d-' $INSTANCE` 
	rm  -f  /dev/shm/${INSTKEY}* >/dev/null 2>&1
    else # BUILD_SYS = kbuild
	MSGD_PID=`pidof msgd:$INSTANCE`
	if [ "$MSGD_PID" != "" ] ; then
	    kill $MSGD_PID
	fi
    fi

    for module in $MODULES_UNLOAD ; do
	if [ "$module" == "shmdrv" ] ; then
                # shmdrv needs a bit of time until rtapi+hal_lib
		# have detached shm segments
	    sleep 1
	fi
        $RMMOD $module
    done
}

CheckUnloaded(){
# checks to see if all modules were unloaded
    STATUS=
    for module in $MODULES_UNLOAD ; do
	# check to see if the module is installed
	if @LSMOD@ | awk '{print $1}' | grep -x $module >/dev/null ; then
	    echo "ERROR: Could not unload '$module'"
	    STATUS=error
	fi
    done
    if [ -n "$STATUS" ] ; then
	exit 1
    fi
}

CMD=$1

case "$CMD" in
  start|load)
	LoadConfig
	Load || exit $?
	CheckLoaded
	;;
  restart|force-reload)
	LoadConfig
	CheckMem
	Unload
	CheckUnloaded
	Load || exit $?
	CheckLoaded
	;;
  stop|unload)
	LoadConfig
	CheckMem
	Unload || exit $?
	;;
  status)
	LoadConfig
	CheckKernel
	CheckStatus
	;;
  *)
	echo "Usage: $0 {start|load|stop|unload|restart|force-reload|status}" >&2
	exit 1
	;;
esac

exit 0

